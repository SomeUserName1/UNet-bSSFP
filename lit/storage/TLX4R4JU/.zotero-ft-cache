Averaging Weights Leads to Wider Optima and Better Generalization

arXiv:1803.05407v3 [cs.LG] 25 Feb 2019

Pavel Izmailov∗1 Dmitrii Podoprikhin∗2,3 Timur Garipov∗4,5 Dmitry Vetrov2,3 Andrew Gordon Wilson1 1Cornell University, 2Higher School of Economics, 3Samsung-HSE Laboratory, 4Samsung AI Center in Moscow, 5Lomonosov Moscow State University

Abstract
Deep neural networks are typically trained by optimizing a loss function with an SGD variant, in conjunction with a decaying learning rate, until convergence. We show that simple averaging of multiple points along the trajectory of SGD, with a cyclical or constant learning rate, leads to better generalization than conventional training. We also show that this Stochastic Weight Averaging (SWA) procedure ﬁnds much ﬂatter solutions than SGD, and approximates the recent Fast Geometric Ensembling (FGE) approach with a single model. Using SWA we achieve notable improvement in test accuracy over conventional SGD training on a range of state-of-the-art residual networks, PyramidNets, DenseNets, and ShakeShake networks on CIFAR-10, CIFAR-100, and ImageNet. In short, SWA is extremely easy to implement, improves generalization, and has almost no computational overhead.
1 INTRODUCTION
With a better understanding of the loss surfaces for multilayer networks, we can accelerate the convergence, stability, and accuracy of training procedures in deep learning. Recent work [Garipov et al., 2018, Draxler et al., 2018] shows that local optima found by SGD can be connected by simple curves of near constant loss. Building upon this insight, Garipov et al. [2018] also developed Fast Geometric Ensembling (FGE) to sample multiple nearby points in weight space to create high performing ensembles in the time required to train a single DNN.
FGE uses a high frequency cyclical learning rate with SGD to select networks to ensemble. In Figure 1 (left)
∗Equal contribution.

we see that the weights of the networks ensembled by FGE are on the periphery of the most desirable solutions. This observation suggests it is promising to average these points in weight space, and use a network with these averaged weights, instead of forming an ensemble by averaging the outputs of networks in model space. Although the general idea of maintaining a running average of weights traversed by SGD dates back to Ruppert [1988], this procedure is not typically used to train neural networks. It is sometimes applied as an exponentially decaying running average in combination with a decaying learning rate (where it is called an exponential moving average), which smooths the trajectory of conventional SGD but does not perform very differently. However, we show that an equally weighted average of the points traversed by SGD with a cyclical or high constant learning rate, which we refer to as Stochastic Weight Averaging (SWA), has many surprising and promising features for training deep neural networks, leading to a better understanding of the geometry of their loss surfaces. Indeed, SWA with cyclical or constant learning rates can be used as a drop-in replacement for standard SGD training of multilayer networks — but with improved generalization and essentially no overhead. In particular:
• We show that SGD with cyclical [e.g., Loshchilov and Hutter, 2017] and constant learning rates traverses regions of weight space corresponding to high-performing networks. We ﬁnd that while these models are moving around this optimal set they never reach its central points. We show that we can move into this more desirable space of points by averaging the weights proposed over SGD iterations.
• While FGE ensembles [Garipov et al., 2018] can be trained in the same time as a single model, test predictions for an ensemble of k models requires k times more computation. We show that SWA can be interpreted as an approximation to FGE ensembles but with the test-time, convenience, and inter-

Test error (%) > 50

30
W2
20

50 35.97 28.49

10

WSWA

W1

W3

0

24.5 22.38 21.24

−10

−10

0

10

20

30

40

50

20.64 19.95

Test error (%) > 50

10

WSGD

50

35.11

27.52 5
23.65

0
epoch 125

WSWA

21.67 20.67 20.15

−5

0

5

10

15

20

25

19.62

Train loss

10

WSGD

5
0
epoch 125

WSWA

−5

0

5

10

15

20

25

> 0.8832 0.8832 0.4391 0.2206 0.1131 0.06024 0.03422 0.02142 0.00903

Figure 1: Illustrations of SWA and SGD with a Preactivation ResNet-164 on CIFAR-1001. Left: test error surface for three FGE samples and the corresponding SWA solution (averaging in weight space). Middle and Right: test error and train loss surfaces showing the weights proposed by SGD (at convergence) and SWA, starting from the same initialization of SGD after 125 training epochs.

pretability of a single model.
• We demonstrate that SWA leads to solutions that are wider than the optima found by SGD. Keskar et al. [2017] and Hochreiter and Schmidhuber [1997] conjecture that the width of the optima is critically related to generalization. We illustrate that the loss on the train is shifted with respect to the test error (Figure 1, middle and right panels, and sections 3, 4). We show that SGD generally converges to a point near the boundary of the wide ﬂat region of optimal points. SWA on the other hand is able to ﬁnd a point centered in this region, often with slightly worse train loss but with substantially better test error.
• We show that the loss function is asymmetric in the direction connecting SWA with SGD. In this direction, SGD is near the periphery of sharp ascent. Part of the reason SWA improves generalization is that it ﬁnds solutions in ﬂat regions of the training loss in such directions.
• SWA achieves notable improvement for training a broad range of architectures over several consequential benchmarks. In particular, running SWA for just 10 epochs on ImageNet we are able to achieve 0.8% improvement for ResNet50 and DenseNet-161, and 0.6% improvement for ResNet-150. We achieve improvement of over 1.3% on CIFAR-100 and of over 0.4% on CIFAR-10 with Preactivation ResNet-164, VGG-16 and Wide ResNet-28-10. We also achieve substantial improvement for the recent Shake-Shake Networks and PyramidNets.
• SWA is extremely easy to implement and has virtually no computational overhead compared to the conventional training schemes.
• We provide an implementation of SWA at https://github.com/timgaripov/swa.

We emphasize that SWA is ﬁnding a solution in the same basin of attraction as SGD, as can be seen in Figure 1, but in a ﬂatter region of the training loss. SGD typically ﬁnds points on the periphery of a set of good weights. By running SGD with a cyclical or high constant learning rate, we traverse the surface of this set of points, and by averaging we ﬁnd a more centred solution in a ﬂatter region of the training loss. Further, the training loss for SWA is often slightly worse than for SGD suggesting that SWA solution is not a local optimum of the loss. In the title of this paper, optima is used in a general sense to mean solutions (converged points of a given procedure), rather than different local minima of the same objective.
2 RELATED WORK
This paper is fundamentally about better understanding the geometry of loss surfaces and generalization in deep learning. We follow the trajectory of weights traversed by SGD, leading to new geometric insights and the intuition that SWA will lead to better results than standard training. Empirically, we make the discovery that SWA notably improves training of many state-of-the-art deep neural networks over a range of consequential benchmarks, with essentially no overhead.
The procedures for training neural networks are constantly being improved. New methods are being proposed for architecture design, regularization and optimization. The SWA approach is related to work in both optimization and regularization.
In optimization, there is great interest in how differ-
1 Suppose we have three weight vectors w1, w2, w3. We set u = (w2 −w1), v = (w3 −w1)− w3 − w1, w2 − w1 / w2 − w1 2 · (w2 − w1). Then the normalized vectors uˆ = u/ u , vˆ = v/ v form an orthonormal basis in the plane containing w1, w2, w3. To visualize the loss in this plane, we deﬁne a Cartesian grid in the basis uˆ, vˆ and evaluate the networks corresponding to each of the points in the grid. A point P with coordinates (x, y) in the plane would then be given by P = w1 + x · uˆ + y · vˆ.

ent types of local solutions affect generalization in deep learning. Keskar et al. [2017] claim that SGD is more likely to converge to broad local optima than batch gradient methods, which tend to converge to sharp optima. Moreover, they argue that the broad optima found by SGD are more likely to have good test performance, even if the training loss is worse than for the sharp optima. On the other hand Dinh et al. [2017] argue that all the known deﬁnitions of sharpness are unsatisfactory and cannot on their own explain generalization. Chaudhari et al. [2017] propose the Entropy-SGD method that explicitly forces optimization towards wide valleys. They report that although the optima found by Entropy-SGD are wider than those found by conventional SGD, the generalization performance is still comparable.
The SWA method is based on averaging multiple points along the trajectory of SGD with cyclical or constant learning rates. The general idea of maintaining a running average of weights proposed by SGD was ﬁrst considered in convex optimization by Ruppert [1988] and later by Polyak and Juditsky [1992]. However, this procedure is not typically used to train neural networks. Practitioners instead sometimes use an exponentially decaying running average of the weights found by SGD with a decaying learning rate, which smooths the trajectory of SGD but performs comparably.
SWA is making use of multiple samples gathered through exploration of the set of points corresponding to high performing networks. To enforce exploration we run SGD with constant or cyclical learning rates. Mandt et al. [2017] show that under several simplifying assumptions running SGD with a constant learning rate is equivalent to sampling from a Gaussian distribution centered at the minimum of the loss, and the covariance of this Gaussian is controlled by the learning rate. Following this explanation from [Mandt et al., 2017], we can interpret points proposed by SGD as being constrained to the surface of a sphere, since they come from a high dimensional Gaussian distribution. SWA effectively allows us to go inside the sphere to ﬁnd higher density solutions.
In a procedure called Fast Geometric Ensembling (FGE), Garipov et al. [2018] showed that using a cyclical learning rate it is possible to gather models that are spatially close to each other but produce diverse predictions. They used the gathered models to train ensembles with no computational overhead compared to training a single DNN model. In recent work Neklyudov et al. [2018] also discuss an efﬁcient approach for model averaging of Bayesian neural networks. SWA was inspired by following the trajectories of FGE proposals, in order to ﬁnd a single model that would approximate an FGE ensemble, but provide greater interpretability, convenience, and

test-time scalability.
Dropout [Srivastava et al., 2014] is an extremely popular approach to regularizing DNNs. Across each minibatch used for SGD, a different architecture is created by randomly dropping out neurons. The authors make analogies between dropout, ensembling, and Bayesian model averaging. At test time, an ensemble approach is proposed, but then approximated with similar results by multiplying each connection by the dropout rate. At a high level, SWA and Dropout are both at once regularizers and training procedures, motivated to approximate an ensemble. Each approach implements these high level ideas quite differently, and as we show in our experiments, can be combined for improved performance.
3 STOCHASTIC WEIGHT AVERAGING
We present Stochastic Weight Averaging (SWA) and analyze its properties. In section 3.1, we consider trajectories of SGD with a constant and cyclical learning rate, which helps understand the geometry of SGD training for neural networks, and motivates the SWA procedure. Then in section 3.2 we present the SWA algorithm in detail, in section 3.3 we derive its complexity, and in section 3.4 we analyze the width of solutions found by SWA versus conventional SGD training. In section 3.5 we then examine the relationship between SWA and the recently proposed Fast Geometric Ensembling [Garipov et al., 2018]. Finally, in section 3.6 we consider SWA from the perspective of stochastic convex optimization.
We note the name SWA has two meanings: on the one hand, it is an average of SGD weights. On the other, with a cyclical or constant learning rate, SGD proposals are approximately sampling from the loss surface of the DNN, leading to stochastic weights.
3.1 ANALYSIS OF SGD TRAJECTORIES
SWA is based on averaging the samples proposed by SGD using a learning rate schedule that allows exploration of the region of weight space corresponding to high-performing networks. In particular we consider cyclical and constant learning rate schedules.
The cyclical learning rate schedule that we adopt is inspired by Garipov et al. [2018] and Smith and Topin [2017]. In each cycle we linearly decrease the learning rate from α1 to α2. The formula for the learning rate at iteration i is given by
α(i) = (1 − t(i))α1 + t(i)α2, t(i) = 1 (mod(i − 1, c) + 1) .
c

α1

Learning rate

α2 n

Test error (%)

50 45 40 35 30 25 20
0

1c

2c

3c

4c

iteration number

Figure 2: Top: cyclical learning rate as a function of iteration. Bottom: test error as a function of iteration for cyclical learning rate schedule with PreactivationResNet-164 on CIFAR-100. Circles indicate iterations corresponding to the minimum learning rates.

The base learning rates α1 ≥ α2 and the cycle length c are the hyper-parameters of the method. Here by iteration we assume the processing of one batch of data. Figure 2 illustrates the cyclical learning rate schedule and the test error of the corresponding points. Note that unlike the cyclical learning rate schedule of Garipov et al. [2018] and Smith and Topin [2017], here we propose to use a discontinuous schedule that jumps directly from the minimum to maximum learning rates, and does not steadily increase the learning rate as part of the cycle. We use this more abrupt cycle because for our purposes exploration is more important than the accuracy of individual proposals. For even greater exploration, we also consider constant learning rates α(i) = α1.
We run SGD with cyclical and constant learning rate schedules starting from a pretrained point for a Preactivation ResNet-164 on CIFAR-100. We then use the ﬁrst, middle and last point of each of the trajectories to deﬁne a 2-dimensional plane in the weight space containing all afﬁne combinations of these points. In Figure 3 we plot the loss on train and error on test for points in these planes. We then project the other points of the trajectory to the plane of the plot. Note that the trajectories do not generally lie in the plane of the plot, except for the ﬁrst, last and middle points, showed by black crosses in the ﬁgure. Therefore for other points of the trajectories it is not possible to tell the value of train loss and test error from the plots.
The key insight from Figure 3 is that both methods explore points close to the periphery of the set of highperforming networks. The visualizations suggest that both methods are doing exploration in the region of space

corresponding to DNNs with high accuracy. The main difference between the two approaches is that the individual proposals of SGD with a cyclical learning rate schedule are in general much more accurate than the proposals of a ﬁxed-learning rate SGD. After making a large step, SGD with a cyclical learning rate spends several epochs ﬁne-tuning the resulting point with a decreasing learning rate. SGD with a ﬁxed learning rate on the other hand is always making steps of relatively large sizes, exploring more efﬁciently than with a cyclical learning rate, but the individual proposals are worse.
Another important insight we can get from Figure 3 is that while the train loss and test error surfaces are qualitatively similar, they are not perfectly aligned. The shift between train and test suggests that more robust central points in the set of high-performing networks can lead to better generalization. Indeed, if we average several proposals from the optimization trajectories, we get a more robust point that has a substantially higher test performance than the individual proposals of SGD, and is essentially centered on the shifted mode for test error. We further discuss the reasons for this behaviour in sections 3.4, 3.5, 3.6.
3.2 SWA ALGORITHM
We now present the details of the Stochastic Weight Averaging algorithm, a simple but effective modiﬁcation for training neural networks, motivated by our observations in section 3.1.
Following Garipov et al. [2018], we start with a pretrained model wˆ. We will refer to the number of epochs required to train a given DNN with the conventional training procedure as its training budget and will denote it by B. The pretrained model wˆ can be trained with the conventional training procedure for full training budget or reduced number of epochs (e.g. 0.75B). In the latter case we just stop the training early without modifying the learning rate schedule. Starting from wˆ we continue training, using a cyclical or constant learning rate schedule. When using a cyclical learning rate we capture the models wi that correspond to the minimum values of the learning rate (see Figure 2), following Garipov et al. [2018]. For constant learning rates we capture models at each epoch. Next, we average the weights of all the captured networks wi to get our ﬁnal model wSWA.
Note that for cyclical learning rate schedule, the SWA algorithm is related to FGE [Garipov et al., 2018], except that instead of averaging the predictions of the models, we average their weights, and we use a different type of learning rate cycle. In section 3.5 we show how SWA can approximate FGE, but with a single model.

Train loss
30

20

10

0

−10

−10

0

10

20

30

40

50

Test error (%)
> 1.7

1.7

30

0.7899 20
0.3758

0.1874 10
0.1017

0.06269

0

0.04494

0.03013

−10

−10

0

10

20

30

40

50

> 50
50 30
35.97
28.49 20 24.5
22.38 10 21.24 20.64 0
19.95

Train loss

0

10

20

30

40

50

> 1.7

1.7 30
0.883

0.5062

20

0.3324

0.2522

10

0.2152

0.1981

0

0.1835

Test error (%)

0

10

20

30

40

50

> 50 50 37.03 30.04 26.28 24.26 23.17 22.58 21.9

Figure 3: The L2-regularized cross-entropy train loss and test error surfaces of a Preactivation ResNet-164 on CIFAR100 in the plane containing the ﬁrst, middle and last points (indicated by black crosses) in the trajectories with (left two) cyclical and (right two) constant learning rate schedules.

Algorithm 1 Stochastic Weight Averaging

Require:

weights wˆ, LR bounds α1, α2,

cycle length c (for constant learning rate c = 1), num-

ber of iterations n

Ensure: wSWA w ← wˆ {Initialize weights with wˆ}

wSWA ← w for i ← 1, 2, . . . , n do

α ← α(i) {Calculate LR for the iteration}

w ← w − α∇Li(w) {Stochastic gradient update}

if mod(i, c) = 0 then

nmodels ← i/c {Number of models}

wSWA

←

wSWA ·nmodels +w nmodels +1

{Update average}

end if

end for

{Compute BatchNorm statistics for wSWA weights}

Batch normalization. If the DNN uses batch normalization [Ioffe and Szegedy, 2015], we run one additional pass over the data, as in Garipov et al. [2018], to compute the running mean and standard deviation of the activations for each layer of the network with wSWA weights after the training is ﬁnished, since these statistics are not collected during training. For most deep learning libraries, such as PyTorch or Tensorﬂow, one can typically collect these statistics by making a forward pass over the data in training mode.
The SWA procedure is summarized in Algorithm 1.
3.3 COMPUTATIONAL COMPLEXITY
The time and memory overhead of SWA compared to conventional training is negligible. During training, we need to maintain a copy of the running average of DNN weights. Note however that the memory consumption in storing a DNN is dominated by its activations rather than its weights, and thus is only slightly increased by the SWA procedure, even for large DNNs (e.g., on the order of 10%). After the training is complete we only need to

store the model that aggregates the average, leading to the same memory requirements as standard training.

During training extra time is only spent to update the aggregated weight average. This operation is of the form

wSWA

←

wSWA · nmodels + w nmodels + 1

,

and it only requires computing a weighted sum of the weights of two DNNs. As we apply this operation at most once per epoch, SWA and SGD require practically the same amount of computation. Indeed, a similar operation is performed as a part of each gradient step, and each epoch consists of hundreds of gradient steps.

3.4 SOLUTION WIDTH
Keskar et al. [2017] and Chaudhari et al. [2017] conjecture that the width of a local optimum is related to generalization. The general explanation for the importance of width is that the surfaces of train loss and test error are shifted with respect to each other and it is thus desirable to converge to the modes of broad optima, which stay approximately optimal under small perturbations. In this section we compare the solutions found by SWA and SGD and show that SWA generally leads to much wider solutions.
Let wSWA and wSGD denote the weights of DNNs trained using SWA and conventional SGD, respectively. Consider the rays
wSWA(t, d) = wSWA + t · d, wSGD(t, d) = wSGD + t · d,
which follow a direction vector d on the unit sphere, starting at wSWA and wSGD, respectively. In Figure 4 we plot train loss and test error of wSWA(t, di) and wSGD(t, di) as a function of t for 10 random directions di, i = 1, 2, . . . , 10 drawn from a uniform distribution on the unit sphere. For this visualization we use a Preactivation ResNet-164 on CIFAR-100.
First, while the loss values on train for wSGD and wSWA are quite similar (and in fact wSGD has a slightly lower

30 28 26 24 22 20
0

5

10

15

20

0.20 0.15 0.10 0.05 0.00
0

5

10

15

20

Figure 4: (Left) Test error and (Right) L2-regularized cross-entropy train loss as a function of a point on a random ray starting at SWA (blue) and SGD (green) solutions for Preactivation ResNet-164 on CIFAR-100. Each line corresponds to a different random ray.

30.0

Test error

27.5

SWA

SGD

25.0

2.5

Train loss

39.5

SWA

2.0

SGD

1.5

34.5

Test error SWA SGD

Train loss

1.5

SWA

SGD

1.0

Test error (%) Train loss
Test error (%) Train loss

22.5

20.0

17.5

−80

−60

−40

−20

0

Distance

1.0

0.5

0.0

20

40

29.5

0.5

24.5

0.0

−60

−40

−20

0

20

40

Distance

Figure 5: L2-regularized cross-entropy train loss and test error as a function of a point on the line connecting SWA and SGD solutions on CIFAR-100. Left: Preactivation ResNet-164. Right: VGG-16.

train loss), the test error for wSGD is lower by 1.5% (at the converged value corresponding to t = 0). Further, the shapes of both train loss and test error curves are considerably wider for wSWA than for wSGD, suggesting that SWA indeed converges to a wider solution: we have to step much further away from wSWA to increase error by a given amount. We even see the error curve for SGD has an inﬂection point that is not present for these distances with SWA.
Notice that in Figure 4 any of the random directions from wSGD increase test error. However, we know that the direction from wSGD to wSWA would decrease test error, since wSWA has considerably lower test error than wSGD. In other words, the path from wSGD to wSWA is qualitatively different from all directions shown in Figure 4, because along this direction wSGD is far from optimal. We therefore consider the line segment connecting wSGD and wSWA:
w(t) = t · wSGD + (1 − t) · wSWA .
In Figure 5 we plot the train loss and test error of w(t) as a function of signed distance from wSWA for Preactivation ResNet-164 and VGG-16 on CIFAR-100.
We can extract several key insights about wSWA and wSGD from Figure 5. First, the train loss and test error plots are indeed substantially shifted, and the point obtained by minimizing the train loss is far from optimal on test.

Second, wSGD lies near the boundary of a wide ﬂat region of the train loss. Further, the loss is very steep near wSGD.
Keskar et al. [2017] argue that the loss near sharp optima found by SGD with very large batches are actually ﬂat in most directions, but there exist directions in which the optima are extremely steep. They conjecture that because of this sharpness the generalization performance of large batch optimization is substantially worse than that of solutions found by small batch SGD. Remarkably, in our experiments in this section we observe that there exist directions of steep ascent even for small batch optima, and that SWA provides even wider solutions (at least along random directions) with better generalization. Indeed, we can see clearly in Figure 5 that SWA is not ﬁnding a different minima than SGD, but rather a ﬂatter region in the same basin of attraction. We can also see clearly that the signiﬁcant asymmetry of the loss function in certain directions, such as the direction SWA to SGD, has a role in understanding why SWA provides better generalization than SGD. In these directions SWA ﬁnds a much ﬂatter solution than SGD, which can be near the periphery of sharp ascent.
3.5 CONNECTION TO ENSEMBLING
Garipov et al. [2018] proposed the Fast Geometric Ensembling (FGE) procedure for training ensembles in the

time required to train a single model. Using a cyclical learning rate, FGE generates a sequence of points that are close to each other in the weight space, but produce diverse predictions. In SWA instead of averaging the predictions of the models we average their weights. However, the predictions proposed by FGE ensembles and SWA models have similar properties.

Let f (·) denote the predictions of a neural network parametrized by weights w. We will assume that f is a scalar (e.g. the probability for a particular class) twice continuously differentiable function with respect to w.

Consider points wi proposed by FGE. These points are

close in the weight space by design, and concentrated

around their average wSWA =

∆i = wi − wSWA. Note

n i=1

1
n
∆i

n
i=1
= 0.

wi. We denote Ensembling the

networks corresponds to averaging the function values

f¯ = 1 n

n

f (wi).

i=1

Consider the linearization of f at wSWA. f (wj) = f (wSWA) + ∇f (wSWA), ∆j + O( ∆j 2),

where ·, · denotes the dot product. Thus, the difference between averaging the weights and averaging the predictions

f¯ −

f (wSWA)

=

1 n

n

∇f (wSWA), ∆i + O( ∆i 2)

i=1

=

∇f

(wSWA),

1 n

n

∆i

+ O(∆2) = O(∆2),

i=1

where ∆ = maxni=1 ∆i . Note that the difference between the predictions of different perturbed networks is

f (wi) − f (wj) = ∇f (wSWA), ∆i − ∆j + O(∆2),

and is thus of the ﬁrst order of smallness, while the difference between averaging predictions and averaging weights is of the second order of smallness. Note that for the points proposed by FGE the distances between proposals are relatively small by design, which justiﬁes the local analysis.
To analyze the difference between ensembling and averaging the weights of FGE proposals in practice, we run FGE for 20 epochs and compare the predictions of different models on the test dataset with a Preactivation ResNet-164 [He et al., 2016] on CIFAR-100. The norm of the difference between the class probabilities of consecutive FGE proposals averaged over the test dataset is 0.126. We then average the weights of the proposals and compute the class probabilities on the test dataset.

The norm of difference of the probabilities for the SWA model and the FGE ensemble is 0.079, which is substantially smaller than the difference between the probabilities of consecutive FGE proposals. Further, the fraction of objects for which consecutive FGE proposals output the same labels is not greater than 87.33%. For FGE and SWA the fraction of identically labeled objects is 95.26%.
The theoretical considerations and empirical results presented in this section suggest that SWA can approximate the FGE ensemble with a single model.

3.6 CONNECTION TO CONVEX MINIMIZATION

Mandt et al. [2017] showed that under strong simplifying assumptions SGD with a ﬁxed learning rate approximately samples from a Gaussian distribution centered at the minimum of the loss. Suppose this is the case when we run SGD with a ﬁxed learning rate for training a DNN.

Let us denote the dimensionality of the weight space of

the neural network by d. Denote the samples produced

by SGD by wi, i = 1, 2, . . . , k. Assume the points wi

are concentrated around the local optimum wˆ. The SWA

solution

is

given

by

wSWA

=

1 n

k i=1

wi.

The

points

wi

are samples from a multidimensional Gaussian N (wˆ, Σ)

for some covariance matrix Σ deﬁned by the curvature of

the loss, batch size and the learning rate. Note that the

samples from a multidimensional Gaussian are concen-

trated on the ellipsoid

z ∈ Rd|

Σ−

1 2

(z

−

wˆ)

√ =d

,

and the probability mass for a sample to end up inside the ellipsoid near wˆ is negligible. On the other hand, wSWA is guaranteed to converge to wˆ as k → ∞.
Moreover, Polyak and Juditsky [1992] showed that averaging SGD proposals achieves the best possible convergence rate among all stochastic gradient algorithms. The proof relies on the convexity of the underlying problem and in general there are no convergence guarantees if the loss function is non-convex [see e.g. Ghadimi and Lan, 2013]. While DNN loss functions are known to be nonconvex [e.g. Choromanska et al., 2015], over the trajectory of SGD these loss surfaces are approximately convex [e.g. Goodfellow et al., 2015]. However, even when the loss is locally non-convex, SWA can improve generalization. For example, in Figure 5 we see that SWA converges to a central point of the training loss.
In other words, there are a set of points that all achieve low training loss. By running SGD with a high constant

Table 1: Accuracies (%) of SWA, SGD and FGE methods on CIFAR-100 and CIFAR-10 datasets for different training budgets. Accuracies for the FGE ensemble are from Garipov et al. [2018].

DNN (Budget)
VGG-16 (200) ResNet-164 (150) WRN-28-10 (200) PyramidNet-272 (300)
VGG-16 (200) ResNet-164 (150) WRN-28-10 (200) ShakeShake-2x64d (1800)

SGD
72.55 ± 0.10 78.49 ± 0.36 80.82 ± 0.23 83.41 ± 0.21
93.25 ± 0.16 95.28 ± 0.10 96.18 ± 0.11 96.93 ± 0.10

FGE (1 Budget) CIFAR-100 74.26 79.84 82.27 – CIFAR-10 93.52 95.45 96.36 –

1 Budget
73.91 ± 0.12 79.77 ± 0.17 81.46 ± 0.23
–
93.59 ± 0.16 95.56 ± 0.11 96.45 ± 0.11
–

SWA 1.25 Budgets
74.17 ± 0.15 80.18 ± 0.23 81.91 ± 0.27 83.93 ± 0.18
93.70 ± 0.22 95.77 ± 0.04 96.64 ± 0.08 97.16 ± 0.10

1.5 Budgets
74.27 ± 0.25 80.35 ± 0.16 82.15 ± 0.27 84.16 ± 0.15
93.64 ± 0.18 95.83 ± 0.03 96.79 ± 0.05 97.12 ± 0.06

or cyclical schedule, we traverse over the surface of this set. Then by averaging the corresponding iterates, we get to move inside the set. This observation explains both convergence rates and generalization. In deep learning we mostly observe beneﬁts in generalization from averaging. Averaging can move to a more central point, which means one has to move further from this point to increase the loss by a given amount, in virtually any direction. By contrast, conventional SGD with a decaying schedule will converge to a point on the periphery of this set. With different initializations conventional SGD will ﬁnd different points on the boundary, of solutions with low training loss, but it will not move inside.
4 EXPERIMENTS
We compare SWA against conventional SGD training on CIFAR-10, CIFAR-100 and ImageNet ILSVRC-2012 [Russakovsky et al., 2012]. We also compare to Fast Geometric Ensembling (FGE) [Garipov et al., 2018], but we note that FGE is an ensemble whereas SWA corresponds to a single model. Conventional SGD training uses a standard decaying learning rate schedule (details in the Appendix) until convergence. We found an exponentially decaying average of SGD to perform comparably to conventional SGD at convergence. We release the code for reproducing the results in this paper at https://github.com/timgaripov/swa.
4.1 CIFAR DATASETS
For the experiments on CIFAR datasets we use VGG16 [Simonyan and Zisserman, 2014], a 164-layer Preactivation-ResNet [He et al., 2016] and Wide ResNet28-10 [Zagoruyko and Komodakis, 2016] models. Additionally, we experiment with the recent Shake-Shake-

2x64d [Gastaldi, 2017] on CIFAR-10 and PyramidNet272 (bottleneck, α = 200) [Han et al., 2016] on CIFAR100. All models are trained using L2-regularization, and VGG-16 also uses dropout.
For each model we deﬁne budget as the number of epochs required to train the model until convergence with conventional SGD training, such that we do not see improvement with SGD beyond this budget. We use the same budgets for VGG, Preactivation ResNet and Wide ResNet models as Garipov et al. [2018]. For ShakeShake and PyramidNets we use the budgets indicated by the papers that proposed these models [Gastaldi, 2017, Han et al., 2016]. We report the results of SWA training within 1, 1.25 and 1.5 budgets of epochs.
For VGG, Wide ResNet and Preactivation-ResNet models we ﬁrst run standard SGD training for ≈ 75% of the training budget, and then use the weights at the last epoch as an initialization for SWA with a ﬁxed learning rate schedule. We ran SWA for 0.25, 0.5 and 0.75 budget to complete the training within 1, 1.25 and 1.5 budgets respectively.
For Shake-Shake and PyramidNet architectures we do not report the results in one budget. For these models we use a full budget to get an initialization for the procedure, and then train with a cyclical learning rate schedule for 0.25 and 0.5 budgets. We used long cycles of small learning rates for Shake-Shake, because this architecture already involves many stochastic components.
We present the details of the learning rate schedules for each of these models in the Appendix.
For each model we also report the results of conventional SGD training, which we denote by SGD. For VGG, Preactivation ResNet and Wide ResNet we also provide the results of the FGE method with one budget reported in

Garipov et al. [2018]. Note that for FGE we report the accuracy of an ensemble of 6 to 12 networks, while for SWA we report the accuracy of a single model.
We summarize the experimental results in Table 1. For all models we report the mean and standard deviation of test accuracy over 3 runs. In all conducted experiments SWA substantially outperforms SGD in one budget, and improves further, as we allow more training epochs. Across different architectures we see consistent improvement by ≈ 0.5% on CIFAR-10 (excluding Shake-Shake, for which SGD performance is already extremely high) and by 0.75-1.5% on CIFAR-100. Amazingly, SWA is able to achieve comparable or better performance than FGE ensembles with just one model. On CIFAR-100 SWA usually needs more than one budget to get results comparable with FGE ensembles, but on CIFAR-10 even with 1 budget SWA outperforms FGE.

4.2 IMAGENET
On ImageNet we experimented with ResNet-50, ResNet152 [He et al., 2016] and DenseNet-161 [Huang et al., 2017]. For these architectures we used pretrained models from PyTorch.torchvision. For each of the models we ran SWA for 10 epochs with a cyclical learning rate schedule with the same parameters for all models (the details can be found in the Appendix), and report the mean and standard deviation of test error averaged over 3 runs. The results are shown in Table 2.
Table 2: Top-1 accuracies (%) on ImageNet for SWA and SGD with different architectures.

DNN ResNet-50 ResNet-152 DenseNet-161

SGD 76.15 78.31 77.65

SWA

5 epochs

10 epochs

76.83 ± 0.01 76.97 ± 0.05

78.82 ± 0.01 78.94 ± 0.07

78.26 ± 0.09 78.44 ± 0.06

For all 3 architectures SWA provides consistent improvement by 0.6-0.9% over the pretrained models.
4.3 EFFECT OF THE LEARNING RATE SCHEDULE
In this section we explore how the learning rate schedule affects the performance of SWA. We run experiments on Preactivation ResNet-164 on CIFAR-100. For all schedules we use the same initialization from a model trained for 125 epochs using the conventional SGD training. As a baseline we use a fully-trained model trained with conventional SGD for 150 epochs.
We consider a range of constant and cyclical learning

Test error (%)

26 25 24 23 22 21 20 19
140

Baseline LR = 0.1 LR = 0.05 LR = 0.01 LR = 0.001

CLR(0.01, 0.0001) CLR(0.005, 0.00005) CLR(0.05, 0.0005) CLR(0.1, 0.001)

160

180

200

220

Epochs

Figure 6: Test error as a function of training epoch for SWA with different learning rate schedules with a Preactivation ResNet-164 on CIFAR-100.

rate schedules. For cyclical learning rates we ﬁx the cycle length to 5, and consider the pairs of base learning rate parameters (α1, α2) ∈ {(10−1, 10−3), (5 · 10−2, 5 · 10−4), (10−2, 10−4), (5 · 10−3, 5 · 10−5)}. Among the constant learning rates we consider α1 ∈ {10−1, 5 · 10−2, 10−2, 10−3}.
We plot the test error of the SWA procedure for different learning rate schedules as a function of the number of training epochs in Figure 6.
We ﬁnd that in general the more aggressive constant learning rate schedule leads to faster convergence of SWA. In our experiments we found that setting the learning rate to some intermediate value between the largest and the smallest learning rate used in the annealing scheme in conventional training usually gave us the best results. The approach is however universal and can work well with different learning rate schedules tailored for particular tasks.
4.4 DNN TRAINING WITH A FIXED LEARNING RATE
In this section we show that it is possible to train DNNs from scratch with a ﬁxed learning rate using SWA. We run SGD with a ﬁxed learning rate of 0.05 on a Wide ResNet-28-10 [Zagoruyko and Komodakis, 2016] for 300 epochs from a random initialization on CIFAR-100. We then averaged the weights at the end of each epoch from epoch 140 and until the end of training. The ﬁnal test accuracy of this SWA model was 81.7.
Figure 7 illustrates the test error as a function of the number of training epochs for SWA and conventional training. The accuracy of the individual models with weights averaged by SWA stays at the level of ≈ 65% which is 16% less than the accuracy of the SWA model. These results correspond to our intuition presented in section 3.6 that SGD with a constant learning rate oscillates around

Test error (%)

50

45

40

35

30

25

SGD

20

Const LR SGD

Const LR SWA

15

0

50

100

150

200

250

300

Epochs

Figure 7: Test error as a function of training epoch for constant (green) and decaying (blue) learning rate schedules for a Wide ResNet-28-10 on CIFAR-100. In red we average the points along the trajectory of SGD with constant learning rate starting at epoch 140.

the optimum, but SWA converges.
While being able to train a DNN with a ﬁxed learning rate is a surprising property of SWA, for practical purposes we recommend initializing SWA from a model pretrained with conventional training (possibly for a reduced number of epochs), as it leads to faster and more stable convergence than running SWA from scratch.
5 DISCUSSION
We have presented Stochastic Weight Averaging (SWA) for training neural networks. SWA is extremely easy to implement, architecture-agnostic, and improves generalization performance at virtually no additional cost over conventional training.
There are so many exciting directions for future research. SWA does not require each weight in its average to correspond to a good solution, due to the geometry of weights traversed by the algorithm. It therefore may be possible to develop SWA for much faster convergence than standard SGD. One may also be able to combine SWA with large batch sizes while preserving generalization performance, since SWA discovers much broader optima than conventional SGD training. Furthermore, a cyclic learning rate enables SWA to explore regions of high posterior density over neural network weights. Such learning rate schedules could be developed in conjunction with stochastic MCMC approaches, to encourage exploration while still providing high quality samples. One could also develop SWA to average whole regions of good solutions, using the high-accuracy curves discovered in Garipov et al. [2018].
A better understanding of the loss surfaces for multilayer networks will help continue to unlock the potential of

these rich models. We hope that SWA will inspire further progress in this area.
Acknowledgements. This work was supported by NSF IIS-1563887, Samsung Research, Samsung Electronics and Russian Science Foundation grant 17-1101027. We also thank Vadim Bereznyuk for helpful comments.
References
P. Chaudhari, Anna Choromanska, S. Soatto, Yann LeCun, C. Baldassi, C. Borgs, J. Chayes, Levent Sagun, and R. Zecchina. Entropy-sgd: Biasing gradient descent into wide valleys. In International Conference on Learning Representations (ICLR), 2017.
Anna Choromanska, Mikael Henaff, Michael Mathieu, Ge´rard Ben Arous, and Yann LeCun. The loss surfaces of multilayer networks. In Artiﬁcial Intelligence and Statistics, pages 192–204, 2015.
Laurent Dinh, Razvan Pascanu, Samy Bengio, and Yoshua Bengio. Sharp minima can generalize for deep nets. In International Conference on Machine Learning, pages 1019–1028, 2017.
Felix Draxler, Kambis Veschgini, Manfred Salmhofer, and Fred Hamprecht. Essentially no barriers in neural network energy landscape. In Proceedings of the 35th International Conference on Machine Learning, pages 1308–1317, 2018.
Timur Garipov, Pavel Izmailov, Dmitrii Podoprikhin, Dmitry P Vetrov, and Andrew Gordon Wilson. Loss surfaces, mode connectivity, and fast ensembling of dnns. arXiv preprint arXiv:1802.10026, 2018.
Xavier Gastaldi. Shake-shake regularization. arXiv preprint arXiv:1705.07485, 2017.
Saeed Ghadimi and Guanghui Lan. Stochastic ﬁrst-and zeroth-order methods for nonconvex stochastic programming. SIAM Journal on Optimization, 23(4): 2341–2368, 2013.
Ian J Goodfellow, Oriol Vinyals, and Andrew M Saxe. Qualitatively characterizing neural network optimization problems. International Conference on Learning Representations, 2015.
Dongyoon Han, Jiwhan Kim, and Junmo Kim. Deep pyramidal residual networks. arXiv preprint arXiv:1610.02915, 2016.
Kaiming He, Xiangyu Zhang, Shaoqing Ren, and Jian Sun. Deep residual learning for image recognition. In Proceedings of the IEEE conference on computer vision and pattern recognition, pages 770–778, 2016.

Sepp Hochreiter and Ju¨rgen Schmidhuber. Flat minima. Neural Computation, 9(1):1–42, 1997.
Gao Huang, Zhuang Liu, Kilian Q Weinberger, and Laurens van der Maaten. Densely connected convolutional networks. In Proceedings of the IEEE conference on computer vision and pattern recognition, volume 1, page 3, 2017.
Sergey Ioffe and Christian Szegedy. Batch normalization: Accelerating deep network training by reducing internal covariate shift. In International Conference on Machine Learning, pages 448–456, 2015.
Nitish Shirish Keskar, Dheevatsa Mudigere, Jorge Nocedal, Mikhail Smelyanskiy, and Ping Tak Peter Tang. On large-batch training for deep learning: Generalization gap and sharp minima. International Conference on Learning Representations, 2017.
Ilya Loshchilov and Frank Hutter. Sgdr: stochastic gradient descent with restarts. International Conference on Learning Representations, 2017.
Stephan Mandt, Matthew D Hoffman, and David M Blei. Stochastic gradient descent as approximate bayesian inference. The Journal of Machine Learning Research, 18(1):4873–4907, 2017.
Kirill Neklyudov, Dmitry Molchanov, Arsenii Ashukha, and Dmitry Vetrov. Variance networks: When expectation does not meet your expectations. arXiv preprint arXiv:1803.03764, 2018.
Boris T Polyak and Anatoli B Juditsky. Acceleration of stochastic approximation by averaging. SIAM Journal on Control and Optimization, 30(4):838–855, 1992.
David Ruppert. Efﬁcient estimations from a slowly convergent robbins-monro process. Technical report, Cornell University Operations Research and Industrial Engineering, 1988.
Olga Russakovsky, Jia Deng, Hao Su, Jonathan Krause, Sanjeev Satheesh, Sean Ma, Zhiheng Huang, Andrej Karpathy, Aditya Khosla, Michael Bernstein, et al. Imagenet large scale visual recognition challenge. International Journal of Computer Vision, 115(3):211– 252, 2012.
Karen Simonyan and Andrew Zisserman. Very deep convolutional networks for large-scale image recognition. arXiv preprint arXiv:1409.1556, 2014.
Leslie N Smith and Nicholay Topin. Exploring loss function topology with cyclical learning rates. arXiv preprint arXiv:1702.04283, 2017.
Nitish Srivastava, Geoffrey Hinton, Alex Krizhevsky, Ilya Sutskever, and Ruslan Salakhutdinov. Dropout: A simple way to prevent neural networks from overﬁtting. The Journal of Machine Learning Research, 15 (1):1929–1958, 2014.

Sergey Zagoruyko and Nikos Komodakis. Wide residual networks. arXiv preprint arXiv:1605.07146, 2016.
A Appendix
A.1 EXPERIMENTAL DETAILS
For the experiments on CIFAR datasets (section 4.1) we used the following implementations (embedded links):
• Shake-Shake-2x64d
• PyramidNet-272
• VGG-16
• Preactivation-ResNet-164
• Wide ResNet-28-10
Models for ImageNet are from here. Pretrained networks can be found here.
SWA learning rates. For PyramidNet SWA uses a cyclic learning rate with α1 = 0.05 and α2 = 0.001 and cycle length 3. For VGG and Wide ResNet we used constant learning α1 = 0.01. For ResNet we used constant learning rates α1 = 0.01 on CIFAR-10 and 0.05 on CIFAR-100.
For Shake-Shake Net we used a custom cyclic learning rate based on the cosine annealing used when training Shake-Shake with SGD. Each of the cycles replicate the learning rates corresponding to epochs 1600 − 1700 of the standard training and the cycle length c = 100 epochs. The learning rate schedule is depicted in Figure 8 and follows the formula
α(i) = 0.1 · 1 + cos π · 1600 + epoch(i) mod 100) , 1800
where epoch(i) is the number of data passes completed before iteration i.
For all experiments with ImageNet we used cyclic learning rate schedule with the same hyperparameters α1 = 0.001, α2 = 10−5 and c = 1.
SGD learning rates. For conventional SGD training we used SGD with momentum 0.9 and with an annealed learning rate schedule. For VGG, Wide ResNet and Preactivation ResNet we ﬁxed the learning rate to α1 for the ﬁrst half of epochs (0B–0.5B), then linearly decreased the learning rate to 0.01α1 for the next 40% of epochs (0.5B–0.9B), and then kept it constant for the last 10% of epochs (0.9B – 1B). For VGG we set α1 = 0.05, and for Preactivation ResNet and Wide ResNet we set

α1

Learning rate

α2

0

100

200

300

400

Epochs

Figure 8: Cyclical learning rate used for Shake-Shake as a function of iteration.

α1 = 0.1. For Shake-Shake Net and PyramidNets we used the cosine and piecewise-constant learning rate schedules described in Gastaldi [2017] and Han et al. [2016] respectively.

A.2 TRAINING RESNET WITH A CONSTANT LEARNING RATE

In this section we present the experiment on training Preactivation ResNet-164 using a constant learning rate. The experimental setup is the same as in section 4.4. We set the learning rate to α1 = 0.1 and start averaging after epoch 200. The results are presented in Figure 9.

Test error (%)

50

SGD

45

Const LR SGD

Const LR SWA

40

35

30

25

20

0

50

100

150

200

250

300

Epochs

Figure 9: Test error as a function of training epoch for constant (green) and decaying (blue) learning rate schedules for a Preactivation ResNet-164 on CIFAR-100. In red we average the points along the trajectory of SGD with constant learning rate starting at epoch 200.

