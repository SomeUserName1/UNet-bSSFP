
Typesetting math: 32%
JavaScript is disabled on your browser. Please enable JavaScript to use all the features on this page. Skip to main content Skip to article
Elsevier logo ScienceDirect

    Journals & Books 

    Search 

Register Sign in

    View  PDF
    Download full issue 

Outline

    Highlights
    Abstract
    Keywords
    1. Introduction
    2. The roots of RNN
    3. RNN unfolding/unrolling
    4. RNN training difficulties
    5. From RNN to vanilla LSTM network
    6. The vanilla LSTM network mechanism in detail
    7. Extensions to the Vanilla LSTM network
    8. Conclusions and future work
    CRediT authorship contribution statement
    Acknowledgments
    References 

Show full outline
Cited by (2389)
Figures (10)

    Fig. 1. Canonical RNN cell
    Fig. 2. Sequence of steps generated by unrolling an RNN cell
    Fig. 3. The unit step and the unit sample (“impulse”) functions plotted (in one data…
    Fig. 4. Expanding the canonical RNN system by adding the “control state” gate, g→cs[n],…
    Fig. 5. The “control readout” gate, g→cr[n], determines the fractional amount of the…
    Fig. 6. In the Vanilla LSTM network, the state signal of the cell at the current step…

Show 4 more figures
Elsevier
Physica D: Nonlinear Phenomena
Volume 404 , March 2020, 132306
Physica D: Nonlinear Phenomena
Fundamentals of Recurrent Neural Network (RNN) and Long Short-Term Memory (LSTM) network
Author links open overlay panel Alex Sherstinsky
Show more
Add to Mendeley
Share
Cite
https://doi.org/10.1016/j.physd.2019.132306 Get rights and content
Highlights

    •

    Recurrent Neural Network (RNN) definition follows from Delay Differential Equations.
    •

    RNN unfolding technique is formally justified as approximating an infinite sequence.
    •

    Long Short-Term Memory Network (LSTM) can be logically rationalized from RNN.
    •

    System diagrams with complete derivation of LSTM training equations are provided.
    •

    New LSTM extensions: external input gate and convolutional input context windows.

Abstract

Because of their effectiveness in broad practical applications, LSTM networks have received a wealth of coverage in scientific journals, technical blogs, and implementation guides. However, in most articles, the inference formulas for the LSTM network and its parent, RNN , are stated axiomatically, while the training formulas are omitted altogether. In addition, the technique of “unrolling” an RNN is routinely presented without justification throughout the literature. The goal of this tutorial is to explain the essential RNN and LSTM fundamentals in a single document. Drawing from concepts in Signal Processing, we formally derive the canonical RNN formulation from differential equations . We then propose and prove a precise statement, which yields the RNN unrolling technique. We also review the difficulties with training the standard RNN and address them by transforming the RNN into the “Vanilla LSTM” 1 network through a series of logical arguments. We provide all equations pertaining to the LSTM system together with detailed descriptions of its constituent entities. Albeit unconventional, our choice of notation and the method for presenting the LSTM system emphasizes ease of understanding. As part of the analysis, we identify new opportunities to enrich the LSTM system and incorporate these extensions into the Vanilla LSTM network, producing the most general LSTM variant to date. The target reader has already been exposed to RNNs and LSTM networks through numerous available resources and is open to an alternative pedagogical approach. A Machine Learning practitioner seeking guidance for implementing our new augmented LSTM model in software for experimentation and research will find the insights and derivations in this treatise valuable as well.

    Previous article in issue
    Next article in issue 

Keywords
RNN
RNN unfolding/unrolling
LSTM
External input gate
Convolutional input context windows
1. Introduction

Since the original 1997 LSTM paper  [1] , numerous theoretical and experimental works have been published on the subject of this type of an RNN , many of them reporting on the astounding results achieved across a wide variety of application domains where data is sequential. The impact of the LSTM network has been notable in language modeling, speech-to-text transcription, machine translation , and other applications  [2] . Inspired by the impressive benchmarks reported in the literature, some readers in academic and industrial settings decide to learn about the Long Short-Term Memory network (henceforth, “the LSTM network”) in order to gauge its applicability to their own research or practical use-case. All major open source machine learning frameworks offer efficient, production-ready implementations of a number of RNN and LSTM network architectures. Naturally, some practitioners, even if new to the RNN/LSTM systems, take advantage of this access and cost-effectiveness and proceed straight to development and experimentation. Others seek to understand every aspect of the operation of this elegant and effective system in greater depth. The advantage of this lengthier path is that it affords an opportunity to build a certain degree of intuition that can prove beneficial during all phases of the process of incorporating an open source module to suit the needs of their research effort or a business application, preparing the dataset, troubleshooting, and tuning.

In a common scenario, this undertaking balloons into reading numerous papers, blog posts, and implementation guides in search of an “A through Z” understanding of the key principles and functions of the system, only to find out that, unfortunately, most of the resources leave one or more of the key questions about the basics unanswered. For example, the Recurrent Neural Network (RNN), which is the general class of a neural network that is the predecessor to and includes the LSTM network as a special case, is routinely simply stated without precedent, and unrolling is presented without justification. Moreover, the training equations are often omitted altogether, leaving the reader puzzled and searching for more resources, while having to reconcile disparate notation used therein. Even the most oft-cited and celebrated primers to date have fallen short of providing a comprehensive introduction. The combination of descriptions and colorful diagrams alone is not actionable, if the architecture description is incomplete, or if important components and formulas are absent, or if certain core concepts are left unexplained.

As of the timeframe of this writing, a single self-contained primer that provides a clear and concise explanation of the Vanilla LSTM computational cell with well-labeled and logically composed schematics that go hand-in-hand with the formulas is still lacking. The present work is motivated by the conviction that a unifying reference, conveying the basic theory underlying the RNN and the LSTM network, will benefit the Machine Learning (ML) community.

The present article is an attempt to fill in this gap, aiming to serve as the introductory text that the future students and practitioners of RNN and LSTM network can rely upon for learning all the basics pertaining to this rich system. With the emphasis on using a consistent and meaningful notation to explain the facts and the fundamentals (while removing mystery and dispelling the myths), this backgrounder is for those inquisitive researchers and practitioners who not only want to know “how”, but also to understand “why”.

We focus on the RNN first, because the LSTM network is a type of an RNN, and since the RNN is a simpler system, the intuition gained by analyzing the RNN applies to the LSTM network as well. Importantly, the canonical RNN equations, which we derive from differential equations , serve as the starting model that stipulates a perspicuous logical path toward ultimately arriving at the LSTM system architecture.

The reason for taking the path of deriving the canonical RNN equations from differential equations is that even though RNNs are expressed as difference equations, differential equations have been indispensable for modeling neural networks and continue making a profound impact on solving practical data processing tasks with machine learning methods. On one hand, leveraging the established mathematical theories from differential equations in the continuous-time domain has historically led to a better understanding of the evolution of the related difference equations, since the difference equations are obtained from the corresponding original differential equations through discretization of the differential operators acting on the underlying functions [3] , [4] , [5] , [6] , [7] , [8] , [9] , [10] . On the other hand, considering the existing deep neurally-inspired architectures as the numerical methods for solving their respective differential equations aided by the recent advances in memory-efficient implementations has helped to successfully stabilize very large models at lower computational costs compared to their original versions  [11] , [12] , [13] . Moreover, differential equations defined on the continuous time domain are a more natural fit for modeling certain real-life scenarios than the difference equations defined over the domain of evenly-discretized time intervals   [14] , [15] .

Our primary aspiration for this document, particularly for the sections devoted to the Vanilla LSTM system and its extensions, is to fulfill all of the following requirements:

    (1)

    Intuitive — the notation and semantics of variables must be descriptive, explicitly and unambiguously mapping to their respective purposes in the system.
    (2)

    Complete — the explanations and derivations must include both the inference equations (“forward pass” or “normal operation”) and the training equations (“backward pass”), and account for all components of the system.
    (3)

    General — the treatment must concern the most inclusive form of the LSTM system (i.e., the “Vanilla LSTM”), specifically including the influence of the cell’s state on control nodes (“pinhole connections”).
    (4)

    Illustrative — the description must include a complete and clearly labeled cell diagram as well as the sequence diagram, leaving nothing to imagination or guessing (i.e., the imperative is: strive to minimize cognitive strain, do not leave anything as an “exercise for the reader” — everything should be explained and made explicit).
    (5)

    Modular — the system must be described in such a way that the LSTM cell can be readily included as part of a pluggable architecture, both horizontally (“deep sequence”) and vertically (“deep representation”).
    (6)

    Vector notation — the equations should be expressed in the matrix and vector form; it should be straightforward to plug the equations into a matrix software library (such as ) as written, instead of having to iterate through indices.

In all sources to date, one or more of the elements in the above list is not addressed 2   [17] , [18] , [19] , [20] , [21] , [22] , [23] , [24] , [25] , [26] , [27] , [28] , [29] , [30] , [31] , [32] , [33] , [34] , [35] , [36] , [37] . Hence, to serve as a comprehensive introduction, the present tutorial captures all the essential details. The practice of using a succinct vector notation and meaningful variable names as well as including the intermediate steps in formulas is designed to build intuition and make derivations easy to follow.

The rest of this document is organized as follows. Section  2 gives a principled background behind RNN systems. Then Section  3 formally arrives at RNN unrolling by proving a precise statement concerning approximating long sequences by a series of shorter, independent sub-sequences (segments). Section  4 presents the RNN training mechanism based on the technique, known as “Back Propagation Through Time”, and explores the numerical difficulties, which occur when training on long sequences. To remedy these problems, Section  5 methodically constructs the Vanilla LSTM cell from the canonical RNN system (derived in Section  2 ) by reasoning through the ways of making RNN more robust. Section  6 provides a detailed explanation of all aspects of the Vanilla LSTM cell. Even though this section is intended to be self-contained, familiarity with the material covered in the preceding sections will be beneficial. The Augmented LSTM system, which embellishes the Vanilla LSTM system with the new computational components, identified as part of the exercise of transforming the RNN to the LSTM network, is presented in Section  7 . Section  8 summarizes the covered topics and proposes future projects.
2. The roots of RNN

In this section, we will derive the Recurrent Neural Network (RNN) from differential equations   [9] , [10] . Let be the value of the -dimensional state signal vector and consider the general nonlinear first-order non-homogeneous ordinary differential equation , which describes the evolution of the state signal as a function of time, : (1) where is a -dimensional vector-valued function of time, , and is a constant -dimensional vector.

One canonical form of is: (2) where is the -dimensional input signal vector and is a vector-valued function of vector-valued arguments.

The resulting system, (3) comes up in many situations in physics , chemistry, biology, and engineering [38] , [39] .

In certain cases, one starts with and as entirely “analog” quantities (i.e., functions not only of time, , but also of another independent continuous variable, , denoting the coordinates in multi-dimensional space). Using this notation, the intensity of an input video signal displayed on a flat -dimensional screen would be represented as with . Sampling on a uniform -dimensional grid converts this signal to the representation , where is now a discrete -dimensional index. Finally, assembling the values of for all permutations of the components of the index, , into a column vector, produces as originally presented in Eq.  (3) above.

One special case of in Eq.  (2) is: (4) whose constituent terms, , , and , are -dimensional vector-valued functions of time, . Eq.  (4) is called the “Additive Model” in Brain Dynamics research literature, because it adds the terms, possibly nonlinear, that determine the rate of change of neuronal activities, or potentials, . As a cornerstone of neural network research, the abstract form of the Additive Model in Eq.  (4) has been particularized in many ways, including incorporating the effects of delays, imposing “shunting” (or “saturating”) bounds on the state of the system, and other factors. Biologically motivated uses of the Additive Model span computational analyses of vision, decision making, reinforcement learning, sensory-motor control, short-term and long-term memory, and the learning of temporal order in language and speech  [40] . It has also been noted that the Additive Model generalizes the Hopfield model  [41] , which, while rooted in biological plausibility , has been influential in physics and engineering  [40] , [42] . In fact, a simplified and discretized form of the Additive Model played a key role in linking the nonlinear dynamical systems governing morphogenesis , one of the fundamental aspects of developmental biology, to a generalized version of the Hopfield network   [41] , and applying it to an engineering problem in image processing   [4] , [43] .

Consider a saturating Additive Model in Eq.  (4) with the three constituent terms, , , and , defined as follows: (5) (6) (7) (8) where , the readout signal vector, is a warped version of the state signal vector, . A popular choice for the element-wise nonlinear, saturating, and invertible “warping” (or “activation”) function, , is an optionally scaled and/or shifted form of the hyperbolic tangent. Then the resulting system, obtained by substituting Eqs.  (5) – (8) into Eq.  (4) and inserting into Eq.  (1) , becomes: (9) (10) Eq.  (9) is a nonlinear ordinary delay differential equation (DDE) with discrete delays. Delay is a common feature of many processes in biology, chemistry, mechanics, physics, ecology, and physiology, among others, whereby the nature of the processes dictates the use of delay equations as the only appropriate means of modeling. In engineering, time delays often arise in feedback loops involving sensors and actuators  [44] .

Hence, the time rate of change of the state signal in Eq.  (9) depends on three main components plus the constant (“bias”) term, . The first (“analog”) component, , is the combination of up to time-shifted (by the delay time constants , ) functions, , where the term “analog” underscores the fact that each is a function of the (possibly time-shifted) state signal itself (i.e., not the readout signal, which is the warped version of the state signal). The second component, , is the combination of up to time-shifted (by the delay time constants, ) functions, , of the readout signal, given by Eq.  (10) , the warped (binary-valued in the extreme) version of the state signal. The third component, , representing the external input, is composed of the combination of up to time-shifted (by the delay time constants, ) functions, , of the input signal. 3

The rationale behind choosing a form of the hyperbolic tangent as the warping function is that the hyperbolic tangent possesses certain useful properties. On one hand, it is monotonic and negative-symmetric with a quasi-linear region, whose slope can be regulated  [45] . On the other hand, it is bipolarly-saturating (i.e., bounded at both the negative and the positive limits of its domain). The quasi-linear mode aides in the design of the system’s parameters and in interpreting its behavior in the “small signal” regime (i.e., when ). The bipolarly-saturating (“squashing”) aspect, along with the proper design of the internal parameters of the functions and , helps to keep the state of the system (and, hence, its output) bounded. The dynamic range of the state signals is generally unrestricted, but the readout signals are guaranteed to be bounded, while still carrying the state information with low distortion in the quasi-linear mode of the warping function (the “small signal” regime). If the system, described by Eqs.  (9) , (10) , is stable, then the state signals are bounded as well  [46] .

Eq.  (9) is a nonlinear ordinary delay differential equation (DDE) with discrete delays. Delay is a common feature of many processes in biology, chemistry, mechanics, physics, ecology, and physiology, among others, whereby the nature of the processes dictates the use of delay equations as the only appropriate means of modeling. In engineering, time delays often arise in feedback loops involving sensors and actuators  [44] .

The time delay terms on the right hand side of Eq.  (9) comprise the “memory” aspects of the system. They enable the quantity holding the instantaneous time rate of change of the state signal, , to incorporate contributions from the state, the readout, and the input signal values, measured at different points in time, relative to the current time, . Qualitatively, these temporal elements enrich the expressive power of the model by capturing causal and/or contextual information.

In neural networks, the time delay is an intrinsic part of the system and also one of the key factors that determines the dynamics. 4 Much of the pioneering research in recurrent networks during the 1970s and the 1980s was founded on the premise that neuron processes and interactions could be expressed as systems of coupled DDEs  [40] , [41] . Far from the actual operation of the human brain, based on what was already known at the time, these “neurally inspired” mathematical models have been shown to exhibit sufficiently interesting emerging behaviors for both, advancing the knowledge and solving real-world problems in various practical applications. While the major thrust of research efforts was concerned primarily with continuous-time networks, it was well understood that the learning procedures could be readily adapted to discrete systems, obtained from the original differential equations through sampling. We will also follow the path of sampling and discretization for deriving the RNN equations  [10] . Over the span of these two decades, pivotal and lasting contributions were made in the area of training networks containing interneurons 5 with “Error Back Propagation” (or “Back Propagation of Error”, or “Back Propagation” for short), a special case of a more general error gradient computation procedure. To accommodate recurrent networks, both continuous-time and discrete-time versions of “Back Propagation Through Time” have been developed on the foundation of Back Propagation and used to train the weights and time delays of these networks to perform a wide variety of tasks  [48] , [49] , [50] , [51] , [52] , [53] . We will rely on Back Propagation Through Time for training the systems analyzed in this paper.

The contribution of each term on the right hand side of Eq.  (9) to the overall system is qualitatively different from that of the others. The functions, , of the (“analog”) state signal in the first term have a strong effect on the stability of the system, while the functions, , of the (bounded) readout signal in the second term capture most of the interactions that shape the system’s long-term behavior. If warranted by the modeling requirements of the biological or physical system and/or of the specific datasets and use-cases in an engineering setting, the explicit inclusion of non-zero delay time constants in these terms provides the necessary weighting flexibility in the temporal domain (e.g., to account for delayed neural interactions)  [54] . Thus, the parameters, , , and representing the counts of the functions, , , and , respectively (and the counts of the associated delay time constants, , , and , respectively, of these functions), in the system equations are chosen (or estimated by an iterative procedure) accordingly.

Suppose that , , and are linear functions of , , and , respectively. Then Eq.  (9) becomes a nonlinear DDE with linear (matrix-valued) coefficients: (11) Furthermore, if the matrices, , , and , are circulant (or block circulant), then the matrix–vector multiplication terms in Eq.  (11) can be expressed as convolutions in the space of the elements of , , , and , each indexed by : (12) The index, , is -dimensional if the matrices, , , and , are circulant and multi-dimensional if they are block circulant. 6

The summations of time delayed terms in Eq.  (12) represent convolutions in the time domain with finite-sized kernels, consisting of the spatial convolutions , , and as the coefficients for the three temporal components, respectively. In fact, if the entire data set (e.g., the input data set, ) is available a priori for all time ahead of the application of Eq.  (12) , then some of the corresponding time delays (e.g.,  ) can be negative, thereby allowing the incorporation of “future” information for computing the state of the system at the present time, . This will become relevant further down in the analysis.

Before proceeding, it is interesting to note that earlier studies linked the nonlinear dynamical system, formalized in Eq.  (9) (with and all , , and set to zero), to the generalization of a type of neural networks. 7 Specifically the variant, in which the functions , , and are linear operators as in Eq.  (11) (with and all , , and set to zero) was shown to include the Continuous Hopfield Network  [41] as a special case. Its close relative, in which these operators are further restricted to be convolutional as in Eq.  (12) (again, with and all , , and set to zero), was shown to include the Cellular Neural Network  [55] , [56] as a special case  [4] , [43] , [46] .

Applying the simplifications: (13) (some of which will be later relaxed) to Eq.  (11) turns it into: (14) Eq.  (11) , Eq.  (12) , and, hence, Eq.  (14) are nonlinear first-order non-homogeneous DDEs. A standard numerical technique for evaluating these equations, or, in fact, any embodiments of Eq.  (1) , is to discretize them in time and compute the values of the input signals and the state signals at each time sample up to the required total duration, thereby performing numerical integration.

Denoting the duration of the sampling time step as and the index of the time sample as in the application of the backward Euler discretization rule 8 to Eq.  (14) yields 9 : (15) (16) (17) (18) (19) Now set the delay, , equal to the single time step. This can be interpreted as storing the value of the readout signal into memory at every time step to be used in the above equations at the next time step. After a single use, the memory storage can be overwritten with the updated value of the readout signal to be used at the next time step, and so forth. 10 Thus, setting and replacing the approximation sign with an equal sign for convenience in Eq.  (19) gives: (20) (21) (22) After performing the discretization, all measurements of time in Eq.  (22) become integral multiples of the sampling time step, . Now, can be dropped from the arguments, which leaves the time axis dimensionless. Hence, all the signals are transformed into sequences, whose domain is the discrete index, , and Eq.  (14) turns into a nonlinear first-order non-homogeneous difference equation  [58] : (23) (24) Defining: (25) and multiplying both sides of Eq.  (24) by leads to: which after shifting the index, , forward by step becomes: (26) Defining two additional weight matrices and a bias vector, (27) (28) (29) transforms the above system into the canonical Recurrent Neural Network (RNN) form: (30) (31) The RNN formulation in Eq.  (30) , diagrammed in Fig. 1 , will be later logically evolved into the LSTM system. Before that, it is beneficial to introduce the process of “unrolling” 11 and the notion of a “cell” of an RNN. These concepts will be simpler to describe using the standard RNN definition, which is derived next from Eq.  (30) based on stability arguments.

For the system in Eq.  (30) to be stable, every eigenvalue of must lie within the complex-valued unit circle  [38] , [58] . Since there is considerable flexibility in the choice of the elements of and to satisfy this requirement, setting for simplicity is acceptable. As another simplification, let be a diagonal matrix with large negative entries (i.e.,  ) on its main diagonal (thereby practically guaranteeing the stability of Eq.  (14) ). Then, from Eq.  (25) , will be a diagonal matrix with small positive entries, , on its main diagonal, which means that the explicit effect of the state signal’s value from memory, , on the system’s trajectory will be negligible (the implicit effect through will still be present as long as ). Thus, ignoring the first term in Eq.  (30) , reduces it to the standard RNN definition: (32) (33) From Eq.  (32) , now only the matrix is responsible for the stability of the RNN. Consider the best case scenario , where is a symmetric matrix ( ). With this simplification, the essential matrix for analyzing the stability of Eq.  (32) becomes , where is the orthogonal matrix of the eigenvectors of , and is the diagonal matrix of the eigenvalues of (with the individual eigenvalues, , on the main diagonal of ). Since is diagonal and is orthogonal, is a diagonal matrix with the entries on its main diagonal. These quantities become the eigenvalues of the overall RNN system in Eq.  (32) in the “small signal regime” ( ), each adding the mode of , multiplied by its corresponding initial condition, to the trajectory of . A necessary and sufficient condition for stability is that , meaning that every eigenvalue, , of must satisfy the condition . If any and fail to satisfy this condition, the system will be unstable, causing the elements of to either oscillate or saturate (i.e., enter the flat regions of the warping nonlinearity) at some value of the index, .

    Download : Download high-res image (130KB)
    Download : Download full-size image 

Fig. 1 . Canonical RNN cell. The bias parameters, , have been omitted from the figure for brevity. It can be assumed to be included without the loss of generality by appending an additional element, always set to , to the input signal vector, , and increasing the row dimensions of by .

An alternative to choosing the specific convenient form of in Eq.  (25) would be to (somewhat arbitrarily) treat , , , and in Eq.  (30) as mutually independent parameters and then set to obtain the standard RNN definition (as in Eq.  (32) ). In this case, the above stability analysis still applies. In particular, the eigenvalues, , of are subject to the same requirement, , as a necessary and sufficient condition for stability.

Stability considerations will be later revisited in order to justify the need to evolve the RNN to a more complex system, namely, the LSTM network.

We have shown that the RNN, as expressed by Eq.  (30) (in the canonical form) or by Eq.  (32) (in the standard form), essentially implements the Backward Euler numerical integration method for the ordinary DDE in Eq.  (14) . This “forward” direction of starting in the continuous-time domain (differential equation) and ending in the discrete-index domain (difference equation) implies that the original phenomenon being modeled is assumed to be fundamentally analog in nature, and that it is modeled in the discrete domain as an approximation for the purpose of realization. For example, the source signal could be the audio portion of a lecture, recorded on an analog tape (or on digital media as a finely quantized waveform and saved in an audio file). The original recording thus contains the spoken words as well as the intonation, various emphases, and other vocal modulations that communicate the content in the speaker’s individual way as expressed through voice. The samples generated by a hypothetical discretization of this phenomenon, governed in this model by Eq.  (14) , could be captured as the textual transcript of the speech, saved in a document containing only the words uttered by the speaker, but ignoring all the intonation, emotion, and other analogous nuances. In this scenario, it is the sequence of words in the transcript of the lecture that the RNN will be employed to reproduce, not the actual audio recording of the speech. The key subtle point in this scenario is that applying the RNN as a model implies that the underlying phenomenon is governed by Eq.  (14) , whereby the role of the RNN is that of implementing the computational method for solving this DDE. In contrast, the “reverse” direction would be a more appropriate model in situations where the discrete signal is the natural starting domain, because the phenomenon originates as a sequence of samples. For example, a written essay originates as a sequence of words and punctuation, saved in a document. One can conjure up an analog rendition of this essay as being read by a narrator, giving life to the words and passages with intonation, pauses, and other expressions not present in the original text of the essay. While the starting point depends on how the original source of data is generated, both the continuous (“forward”) and the discrete (“reverse”) representations can serve as tools for gaining insight into the advantages and the limitations of the models under consideration.
3. RNN unfolding/unrolling

It is convenient to use the term “cell” when referring to Eqs.  (30) , (32) in the uninitialized state. In other words, the sequence has been defined by these equations, but its terms not yet computed. Then the cell can be said to be “unfolded” or “unrolled” by specifying the initial conditions on the state signal, , and numerically evaluating Eq.  (30) or Eq.  (32) for a finite range of discrete steps, indexed by . This process is illustrated in Fig. 2 .

Both Eqs.  (30) , (32) are recursive in the state signal, . Hence, due to the repeated application of the recurrence relation as part of the unrolling, the state signal, , at some value of the index, , no matter how large, encompasses the contributions of the state signal, , and the input signal, , for all indices, , ending at , the start of the sequence  [48] , [52] . Because of this attribute, the RNN belongs to the category of the “Infinite Impulse Response” (IIR) systems.

    Download : Download high-res image (106KB)
    Download : Download full-size image 

Fig. 2 . Sequence of steps generated by unrolling an RNN cell.

Define the vector-valued unit step function as: (34) where and denote vectors, all of whose elements are equal to and to , respectively. Then the vector-valued unit sample function, , is defined by being at , and otherwise. In terms of , (35) These functions are depicted in Fig. 3 .

    Download : Download high-res image (122KB)
    Download : Download full-size image 

Fig. 3 . The unit step and the unit sample (“impulse”) functions plotted (in one data dimension) against the discrete index, .

Example 1

The IIR (i.e., unending) nature of the sequences, governed by these equations, can be readily demonstrated by letting be the initial condition, setting , the unit sample stimulus (i.e., the “impulse”), and computing the response, , to this “impulse” for several values of the index, , in order to try to recognize a pattern. In the case of Eq.  (32) with , the sequence of values will be: (36) and so forth. Evidently, it is defined for every positive , even when the input is only a single impulse at .

In practice, it is desirable to approximate a sequence with an infinite support (IIR), such as Eq.  (30) or Eq.  (32) , by a “Finite Impulse Response” (FIR) sequence. The rationale is that FIR systems have certain advantages over IIR systems. One advantage is guaranteed stability — FIR systems are intrinsically stable. Another advantage is that FIR systems are realizable with finite computational resources. An FIR system will take a finite number of steps to compute the output from the input and will require a finite number of memory locations for storing intermediate results and various coefficients. Moreover, the computational complexity and storage requirements of an FIR system are known at design time.

Denote the sequence of the “ground truth” output values by for any value of the index, , and let be the length of the sequence, , where can be an arbitrarily large integer (e.g., the total number of samples in the training set, or the number of inputs presented to the system for inference over the lifetime of the system, etc.). Suppose that is subdivided into non-overlapping varying-length segments with samples per segment, where every is finite, and . It can be assumed that is an integer with (if needed, the RNN system in Eq.  (32) can be “padded” with extra input terms for this to hold).

Formally, let be the sequence of the ground truth output values for any value of the index, , and assume that there exists a partitioning of into non-overlapping segments, , : (37) For subdividing a sequence into non-overlapping segments, consider a vector-valued “rectangular” window function , , which has the value of within the window and otherwise. In terms of the vector-valued unit step function, , is defined as: (38) Combining Eq.  (35) with Eq.  (38) provides an alternative (“sampling”) definition of : (39) Then from Eq.  (39) , the RNN sequence can be sampled in its entirety by the full -samples-long window: (40) (41) where: (42) and: (43) Under the change of indices, Eq.  (43) becomes: (44) Eq.  (44) indicates that each is a rectangular window, whose size is samples. Hence, “extracting” a -samples-long segment with the index, , from the overall ground truth output sequence , , amounts to multiplying this sequence by : (45) (46) where is given by Eq.  (42) . According to Eq.  (46) , the segment-level ground truth output subsequence, , in Eq.  (45) will have non-zero values for the given value of the segment index, , where , only when the index, , is in the range . This is in agreement with Eq.  (37) .

Define as an invertible map that transforms an ensemble of the readout signals of the RNN system, , into an ensemble of observable output signals, , for : (47) In addition, define as an “objective function” (or “merit function”  [59] ) that measures the cost of the observable output of the system deviating from the desired ground truth output values, given the input data , supplied over the entire range of the values of the index, : (48) where denotes the ensemble of all members of the sequence of the observable output variables, , and denotes the ensemble of all members of the sequence of the ground truth output values, .

As shorthand, combine all parameters of the standard RNN system in Eq.  (32) under one symbol, : (49)

Proposition 1

Given the standard RNN system in  Eq.  (32) parameterized by , defined in  Eq.  (49) , assume that there exists a value of , at which the objective function, , defined in  Eq.  (48) for an -samples-long sequence, is close to an optimum as measured by some acceptable bound. Further, assume that there exist non-zero finite constants, and , such that , where , and that the ground truth output sequence, , can be partitioned into mutually independent segment-level ground truth output subsequences, , for different values of the segment index, , as specified in Eq.  (46) . Then a single, reusable RNN cell, unrolled for an adjustable number of steps, , is computationally sufficient for seeking that optimizes over the training set and for inferring outputs from unseen inputs.

Proof

The objective function in Eq.  (48) computes the error in the system’s performance during training, validation, and testing phases as well as tracks its generalization metrics on the actual application data during the inference phase. By the assumption, can be optimized. This implies that when is acceptably close to an optimum, the observable output ensemble from the RNN system approximates the ground truth output ensemble within a commensurately acceptable tolerance bound: (50) Segmenting the RNN system’s output sequence by the same procedure as was used in Eq.  (45) to segment the ground truth output sequence gives: (51) (52) where is given by Eq.  (42) . According to Eq.  (52) , the segment-level output subsequence, , in Eq.  (51) will have non-zero values for the given value of the segment index, , where , only when the index, , is in the range .

By the assumption that the segment-level ensembles of the ground truth output subsequences are mutually independent, the objective function in Eq.  (48) is separable and can be expressed as a set of independent segment-level components, , , combined by a suitable function, : (53) Then by Eqs.  (50) , (53) , (54) for all values of the segment index, , where . In other words, the tracking of the ground truth output by the observable output of the RNN system at the entire -sample ensemble level must hold at the -samples-long segment level, too, for all segments.

Since is invertible, (55) and since the warping function, , in Eq.  (33) is invertible, then for any value of the sample index, , (56) According to Eqs.  (50) , (55) , and  (56) , , , and are all functions of random variables. Let and be the ground truth output subsequence ensembles, belonging to any two segments, whose indices are and , respectively, with . By the assumption, and are independent random variables . Because the functions of independent variables are also independent, it follows that at the segment level the observable output signal subsequence ensembles, and , are independent, the readout signal subsequence ensembles, and , are independent, and the state signal subsequences, and , are independent.

The mutual independence of the state signal subsequences, , for different values of the segment index, , places a restriction on the initial conditions of these subsequences. Specifically, the initial condition for the state signal subsequence of one segment cannot be a function of samples belonging to either the state signal subsequence or the input signal subsequence of another segment for any value of the index,  .

Performing the element-wise multiplication of the input sequence, , by the sampling window, , extracts a segment-level input sequence with the index, : (57) (58) where is given by Eq.  (42) . According to Eq.  (58) , the segment-level input subsequence, , in Eq.  (57) will have non-zero values for the given value of the segment index, , where , only when the index, , is in the range .

Due to recursion, the members of the state signal sequence, , in an RNN system can in general depend on the entire input signal sequence assembly. However, since under the present assumptions the segment-level state signal subsequences, and , belonging to different segments, are independent, the dependency of on the input signal must be limited to the same segment-level subsequence (i.e., with segment index, ). If we define as a map that transforms the segment-level input signal subsequence assembly, , into the segment-level state signal subsequence assembly, , then the standard RNN system definition in Eq.  (32) at the -samples-long segment level can be expressed as: (59) Hence, for any with , the restriction, (60) must be enforced in order to satisfy the independence of the segment-level state signal subsequences. The only way to achieve this is to set to a random vector or to . The latter choice is adopted here for simplicity.

Thus, substituting Eqs.  (58) , (60) into Eq.  (32) yields the RNN system equations for an individual segment: (61) (62) (63) (64) Making the index substitution, shifts the segment-level subsequences, , s → m [ n ] 0 ≤ n ≤ N − 1 , and x → m [ n ] 0 ≤ n ≤ N − 1 , by − j ( m ) samples: (65) x ̃ → m [ n ] ≡ x → m [ n + j ( m ) ] 0 ≤ n ≤ N − 1 = x → [ n + j ( m ) ] , j ( m ) ≤ n + j ( m ) ≤ j ( m ) + K m − 1 0 → , otherwise = x → [ n + j ( m ) ] , 0 ≤ n ≤ K m − 1 0 → , otherwise (66) r ̃ → m [ n ] ≡ r → m [ n + j ( m ) ] 0 ≤ n ≤ N − 1 (67) s ̃ → m [ n ] ≡ s → m [ n + j ( m ) ] 0 ≤ n ≤ N − 1 = W r r → m [ n + j ( m ) − 1 ] + W x x → m [ n + j ( m ) ] + θ → s , j ( m ) ≤ n + j ( m ) ≤ j ( m ) + K m − 1 0 → , otherwise = W r r ̃ → m [ n − 1 ] + W x x ̃ → m [ n ] + θ → s , 0 ≤ n ≤ K m − 1 0 → , otherwise (68) s ̃ → m [ n = − 1 ] ≡ s → m [ n + j ( m ) = j ( m ) − 1 ] = 0 → Simplified, these equations reduce to the form of the standard RNN system, unrolled for K m steps, for any segment with the index, m , where 0 ≤ m ≤ M − 1 : (69) s ̃ → m [ n = − 1 ] = 0 → (70) s ̃ → m [ n ] = W r r ̃ → m [ n − 1 ] + W x x ̃ → m [ n ] + θ → s , 0 ≤ n ≤ K m − 1 0 → , otherwise (71) r ̃ → m [ n ] = G ( s ̃ → m [ n ] ) , 0 ≤ n ≤ K m − 1 0 → , otherwise (72) x ̃ → m [ n ] = x → [ n + j ( m ) ] , 0 ≤ n ≤ K m − 1 0 → , otherwise It follows that the shifted segment-level state signal subsequences, s ̃ → m [ n ] 0 ≤ n ≤ K m − 1 , for different values of the segment index, m , where 0 ≤ m ≤ M − 1 , are mutually independent. In addition, from Eqs.  (71) , (70) , and  (72) , the non-zero values of the resulting sequences, r ̃ → m [ n ] 0 ≤ n ≤ K m − 1 , s ̃ → m [ n ] 0 ≤ n ≤ K m − 1 , and x ̃ → m [ n ] 0 ≤ n ≤ K m − 1 , are confined to 0 ≤ n ≤ K m − 1 for any value of the segment index, m , where 0 ≤ m ≤ M − 1 .

As the sample index, n , traverses the segment-level range, 0 ≤ n ≤ K m − 1 , for every segment with the index, m , where 0 ≤ m ≤ M − 1 , the input subsequence, x ̃ → m [ n ] , takes on all the available values of the input sequence, x → [ n ] , segment by segment. Similarly to the original RNN system in Eq.  (32) , the input signal, x ̃ → m [ n ] (the external driving force), is the only independent variable of the RNN system, unrolled for K m steps, in Eq.  (70) . Together with the mutual independence of s ̃ → m [ n ] 0 ≤ n ≤ K m − 1 for different segments, this makes the computations of the RNN system, unrolled for K m steps, generic for all segments. The only signal that retains the dependence on the segment index, m , is the input. Dropping the segment subscript, m , from the variables representing the state signal and the readout signal results in the following prototype formulation of the RNN system, unrolled for K m steps: (73) s ̃ → [ n = − 1 ] = 0 → (74) s ̃ → [ n ] = W r r ̃ → [ n − 1 ] + W x x ̃ → m [ n ] + θ → s , 0 ≤ n ≤ K m − 1 0 → , otherwise (75) r ̃ → [ n ] = G ( s ̃ → [ n ] ) , 0 ≤ n ≤ K m − 1 0 → , otherwise (76) x ̃ → m [ n ] = x → [ n + j ( m ) ] , 0 ≤ n ≤ K m − 1 0 → , otherwise (77) 0 ≤ m ≤ M − 1 where j ( m ) is given by Eq.  (42) .

The same prototype variable-length RNN computation, unrolled for K m steps, can process all segments, one at a time. After initializing the segment’s state signal using Eq.  (73) and selecting the input samples for the segment using Eq.  (76) , Eqs.  (74) , (75) are applied for K m steps, 0 ≤ n ≤ K m − 1 . This procedure can then be applied to the next segment using the same computational module, and then to the next segment, and so on, until the inputs comprising all M segments have been processed. Moreover, the mutual independence of the segments facilitates parallelism, whereby the computation of s ̃ → m [ n ] , r ̃ → m [ n ] , and y → m [ n ] for 0 ≤ n ≤ K m − 1 can be carried out for all M segments concurrently.  □

Remark 1

Proposition 1 and its proof do not formally address advanced RNN architectures, such as Gated Recurrent Unit (GRU), Attention Networks, and complex models comprised of multiple LSTM networks.

Remark 2

While the segment-level state signal subsequences, s ̃ → m [ n ] 0 ≤ n ≤ K m − 1 , are independent, there is no independence requirement on the input signal subsequences, x ̃ → m [ n ] , belonging to the different segments. It has been shown that dependencies in the input signal can be de-correlated by appropriately trained hidden layer weights, W x , thus maintaining the independence of s ̃ → m [ n ] 0 ≤ n ≤ K m − 1 [3] , [60] .

Remark 3

It is important to emphasize that no IIR-to-FIR conversion method is optimal in the absolute sense. Finding an optimal FIR approximation to an IIR system can only be done with respect to a certain measure of fidelity and performance. In practice, one must settle for an approximation to the ideal form of the output signal. The success of an approximation technique depends on the degree to which the resulting FIR system can be adapted to fit the specific data distribution and achieve acceptable quality metrics for the given application’s requirements.

Unrolling (or unfolding) for a finite number of steps is a standard, straightforward technique for approximating RNNs by FIR sequences. However, due to the truncation inherent in limiting the number of steps, the resulting unfolded RNN model introduces artificial discontinuities in the approximated version of the target output sequence. In general, the more steps are included in the unrolled RNN subsequence, the closer it can get to the desired output samples, but the less efficient the system becomes, due to the increased number of computations. Nevertheless, if the underlying distribution governing the application generates the sequence under consideration as a series of independent segments (subsequences), then by Proposition 1 , an unfolded RNN model aligned with each segment can be trained to reproduce outputs from inputs in a way that aims to satisfy the appropriate criteria of merit faithfully. In this sense, Proposition 1 for RNNs loosely resembles in spirit the Sampling Theorem in the field of Discrete-Time Signal Processing  [58] . The method of unrolling is also applicable to the scenarios where attention can be restricted to those “present” sections of the output that are influenced to an arbitrarily small extent by the portions of the “past” or the “future” of the input beyond some arbitrarily large but finite step  [61] . As a matter of fact, in certain situations, the raw data set may be amenable to pre-processing, without losing much of the essential information. Suppose that after a suitable cleanup, treating the overall sequence as a collection of independent segments becomes a reasonable assumption. Then by Proposition 1 , the adverse effects of truncation can be reduced by adjusting the number of samples comprising the window of the unrolled RNN system. Moreover, whenever Proposition 1 applies, the segments can be processed by the unrolled RNN system in any order (because they are assumed to be independent). This flexibility is utilized by the modules that split the original data set into segments and feed the batches of segmented training samples to the computational core of system.

Conversely, if the assumptions of Proposition 1 are violated, then truncating the unrolling will prevent the model from adequately fitting the ground truth output. To illustrate this point, suppose that an RNN system, unrolled for a relatively few steps, is being used to fit the target sequence that exhibits extremely long-range dependencies. The unrolled RNN subsequence will be trained under the erroneous assumptions, expecting the ground truth to be a series of short independent subsequences. However, because of its relatively narrow window, this RNN subsequence will not be able to encompass enough samples to capture the dependencies present in the actual data. Under-sampling the distribution will limit the flow of information from the training samples to the parameters of the model, leaving it in the constant state of making poor predictions. As a symptom, the model will repeatedly encounter unexpected variations during training, causing the objective function to oscillate, never converging to an adequate optimum. During inference, the generated sequence will suffer from severe jitter and distortion when compared to the expected output.

Remark 4

According to Proposition 1 , the RNN unrolling technique is justified by partitioning a single output sequence into multiple independent subsequences and placing restrictions on the initialization of the state between subsequences. However, adhering to these conditions may be problematic in terms of modeling sequences in practical applications. Oftentimes, the output subsequences exhibit some inter-dependence and/or the initial state of one subsequence is influenced by the final state of another subsequence. In practice, if the choice for the initial conditions of the state of subsequences is consistent with the process by which the application generates the samples of the input sequence, then a favorable subdivision of the output sequence into acceptably independent subsequences can be found empirically through experimentation and statistical analysis.

4. RNN training difficulties

Proposition 1 establishes that Eqs.  (73) – (77) together with Eq.  (42) specify the truncated unrolled RNN system that realizes the standard RNN system, given by Eqs.  (32) , (33) . We now segue to the analysis of the training technique for obtaining the weights in the truncated unrolled RNN system, with the focus on Eqs.  (74) , (75) .

Once the infinite RNN sequence in Eq.  (32) is truncated (or unrolled to a finite length), the resulting system, given in Eq.  (74) , becomes inherently stable. However, RNN systems are problematic in practice, despite their stability. During training, they suffer from the well-documented issues, known as “vanishing gradients” and “exploding gradients” [1] , [62] , [63] . These difficulties become pronounced when the dependencies in the target subsequence span a large number of samples, requiring the window of the unrolled RNN model to be commensurately wide in order to capture these long-range dependencies.

Truncated unrolled RNN systems, such as Eq.  (74) , are commonly trained using “Back Propagation Through Time” (BPTT), which is the “Back Propagation” technique adapted for sequences [64] , [65] , [66] , [67] . The essence of Back Propagation is the repeated application of the chain rule of differentiation. Computationally, the action of unrolling Eq.  (32) for K steps amounts to converting its associated directed graph having a delay and a cycle, into a directed acyclic graph (DAG) corresponding to Eq.  (74) . For this reason, while originally Back Propagation was restricted to feedforward networks only, subsequently, it has been successfully applied to recurrent networks by taking advantage of the very fact that for every recurrent network there exists an equivalent feedforward network with identical behavior for a finite number of steps  [68] , [69] , [70] .

As a supervised training algorithm, BPTT utilizes the available x ̃ → m [ n ] and r ̃ → [ n ] data pairs (or the respective pairs of some mappings of these quantities) in the training set to compute the parameters of the system, Θ , defined in Eq.  (49) , so as to optimize an objective function, E , which depends on the readout signal, r ̃ → [ n ] , at one or more values of the index, n . If Gradient Descent (or another “gradient type” algorithm) is used to optimize E , then BPTT provides a consistent procedure for deriving the elements of ∂ E ∂ Θ through a repeated application of the chain rule. 12

By assuming that the conditions of Proposition 1 apply, the objective function, E , takes on the same form for all segments. Let us now apply BPTT to Eq.  (74) . Suppose that E depends on the readout signal, r ̃ → [ n ] , at some specific value of the index, n . Then it is reasonable to wish to measure the total gradient of E with respect to r ̃ → [ n ] : (78) χ → [ n ] ≡ ∇ → r ̃ → [ n ] E = ∂ E ∂ r ̃ → [ n ] Since r ̃ → [ n ] is explicitly dependent on s ̃ → [ n ] , it follows that s ̃ → [ n ] also influences E , and one should be interested in measuring the total gradient of E with respect to s ̃ → [ n ] : (79) ψ → [ n ] ≡ ∇ → s ̃ → [ n ] E = ∂ E ∂ s ̃ → [ n ] Quite often in practice, the overall objective function is defined as the sum of separate contributions involving the readout signal, r ̃ → [ n ] , at each individual value of the index, n : (80) E = ∑ n = 0 K m − 1 E ( r ̃ → [ n ] ) Because of the presence of the individual penalty terms, E ( r ̃ → [ n ] ) , in Eq.  (80) for the overall objective function of the system, it may be tempting to use the chain rule directly with respect to r ̃ → [ n ] in isolation and simply conclude that χ → [ n ] in Eq.  (78) is equal to ∂ E ( r ̃ → [ n ] ) ∂ r ̃ → [ n ] ⊙ d G d ( z → ) d z → ⌋ z = s ̃ → [ n ] , where the ⊙ operator denotes the element-wise vector product . However, this would miss an important additional component of the gradient with respect to the state signal. The subtlety is that for an RNN, the state signal, s ̃ → [ n ] , at n = k also influences the state signal, s ̃ → [ n ] , at n = k + 1   [19] , [63] . The dependency of s ̃ → [ n + 1 ] on s ̃ → [ n ] through r ̃ → [ n ] becomes apparent by rewriting Eq.  (74) at the index, n + 1 : (81) s ̃ → [ n + 1 ] = W r r ̃ → [ n ] + W x x ̃ → m [ n + 1 ] + θ → s r ̃ → [ n ] = G ( s ̃ → [ n ] ) r ̃ → [ n + 1 ] = G ( s ̃ → [ n + 1 ] ) Hence, accounting for both dependencies, while applying the chain rule, gives the expressions for the total partial derivative of the objective function with respect to the readout signal and the state signal at the index, n : (82) χ → [ n ] = ∂ E ( r ̃ → [ n ] ) ∂ r ̃ → [ n ] + W r ψ → [ n + 1 ] (83) ψ → [ n ] = χ → [ n ] ⊙ d G ( z → ) d z → ⌋ z = s ̃ → [ n ] (84) = ∂ E ( r ̃ → [ n ] ) ∂ r ̃ → [ n ] + W r ψ → [ n + 1 ] ⊙ d G ( z → ) d z → ⌋ z = s ̃ → [ n ] Eqs.  (82) , (84) show that the total partial derivatives of the objective function form two sequences, which progress in the “backward” direction of the index, n . These sequences represent the dual counterparts of the sequence generated by unrolling Eq.  (74) in the “forward” direction of the index, n . Therefore, just as Eq.  (74) requires the initialization of the segment’s state signal using Eq.  (73) , the sequence formed by the total partial derivative of the objective function with respect to the state signal (commonly designated as the “the error gradient”) requires that Eq.  (82) must also be initialized: (85) ψ → [ n = K m ] = 0 → Applying the chain rule to Eq.  (74) and using Eq.  (84) , gives the expressions for the derivatives of the model’s parameters: (86) ∂ E ∂ Θ [ n ] = ∂ E ∂ W r [ n ] , ∂ E ∂ W x [ n ] , ∂ E ∂ θ → s [ n ] (87) ∂ E ∂ W r [ n ] = ψ → [ n ] r ̃ → T [ n − 1 ] (88) ∂ E ∂ W x [ n ] = ψ → [ n ] x ̃ → m T [ n ] (89) ∂ E ∂ θ → s [ n ] = ψ → [ n ] (90) d E d Θ = ∑ n = 0 K m − 1 ∂ E ∂ Θ [ n ] Note that for an RNN cell, unrolled for K m steps in order to cover a segment containing K m training samples, the same set of the model parameters, Θ , is shared by all the steps. This is because Θ is the parameter of the RNN system as a whole. Consequently, the total derivative of the objective function, E , with respect to the model parameters, Θ , has to include the contributions from all steps of the unrolled sequence. This is captured in Eq.  (90) , which can now be used as part of optimization by Gradient Descent. Another key observation is that according to Eqs.  (87) ,  (88) , and  (89) , all of the quantities essential for updating the parameters of the system, Θ , during training are directly proportional to ψ → [ n ] .

When the RNN system is trained using BPTT, the error gradient signal flows in the reverse direction of the index, n , from that of the sequence itself. Let ψ → [ k ] 0 ≤ k < n denote all terms of the sequence, each of whose elements, ψ → [ k ] , is the gradient of E with respect to the state signal, s ̃ → [ k ] , at the index, k , for all k < n , ending at ψ → [ k = 0 ] , the start of the sequence. Then Eq.  (84) reveals that ψ → [ n ] , the gradient of E with respect to the state signal, s ̃ → [ n ] , at some value of the index, n , no matter how large, can influence the entire ensemble, ψ → [ k ] 0 ≤ k < n . Furthermore, by Proposition 1 , ψ → [ n ] depends on the truncated ensemble, ψ → [ k ] n < k ≤ K m − 1 . Thus, of a particular interest is the fraction of ψ → [ n ] that is retained from back propagating ψ → [ l ] , where l ≫ n . This component of the gradient of the objective function is responsible for adjusting the model’s parameters, Θ , in a way that uses the information available at one sample to reduce the cost of the system making an error at a distant sample. If these types of contributions to ψ → [ n ] 0 ≤ n ≤ K m − 1 are well-behaved numerically, then the model parameters learned by using the Gradient Descent optimization procedure will able to incorporate the long-range interactions among the samples in the RNN window effectively during inference.

Expanding the recursion in Eq.  (84) from the step with the index, n , to the step with the index, l ≤ K m − 1 , where l ≫ n , gives: (91) ∂ ψ → [ n ] ∂ ψ → [ l ] = ∏ k = n + 1 l W r ⊙ d G ( z → ) d z → ⌋ z = s ̃ → [ k ] From Eq.  (91) , the magnitude of the overall Jacobian matrix, ∂ ψ → [ n ] ∂ ψ → [ l ] , depends on the product of l − n individual Jacobian matrices, W r ⊙ d G ( z → ) d z → ⌋ z = s ̃ → [ k ] . 13 Even though the truncated unrolled RNN system is guaranteed to be stable by design, since in the case of long-range interactions the unrolled window size, K m , and the distance between the samples of interest, l − n , are both large, the stability analysis is helpful in estimating the magnitude of ∂ ψ → [ n ] ∂ ψ → [ l ] in Eq.  (91) . If all eigenvalues, μ i , of W r satisfy the requirement for stability, 0 < μ i < 1 , then ‖ W r ‖ < 1 . Combined with the fact that ‖ d G ( z → ) d z → ‖ < 1 (which follows from the choice of the warping function advocated in Section  2 ), this yields: (93) ‖ ∂ ψ → [ n ] ∂ ψ → [ l ] ‖ ∼ ‖ W r ‖ ⋅ ‖ d G ( z → ) d z → ‖ l − n ∼ ‖ W r ‖ l − n ⋅ ‖ d G ( z → ) d z → ‖ l − n ≈ 0 Conversely, if at least one eigenvalue of W r violates the requirement for stability, the term ‖ W r ‖ l − n will grow exponentially. This can lead to two possible outcomes for the RNN system in Eq.  (74) . In one scenario, as the state signal, s ̃ → [ n ] , grows, the elements of the readout signal, r ̃ → [ n ] , eventually saturate at the “rails” (the flat regions) of the warping function. Since in the saturation regime, d G ( z → ) d z → = 0 → , the result is again ‖ ∂ ψ → [ n ] ∂ ψ → [ l ] ‖ ≈ 0 . In another, albeit rare, scenario, the state signal, s ̃ → [ n ] , is initially biased in the quasi-linear region of the warping function, where d G ( z → ) d z → ≠ 0 → . If the input, x ̃ → m [ n ] , then guides the system to stay in this mode for a large number of steps, ‖ ∂ ψ → [ n ] ∂ ψ → [ l ] ‖ will grow, potentially resulting in an overflow. Consequently, training the standard RNN system on windows spanning many data samples using Gradient Descent is hampered by either vanishing or exploding gradients, regardless of whether or not the system is large-signal stable. In either case, as long as Gradient Descent optimization is used for training the RNN, regulating ψ → [ n ] will be challenging in practice, leaving no reliable mechanism for updating the parameters of the system, Θ , in a way that would enable the trained RNN model to infer both r ̃ → [ n ] and r ̃ → [ l ≫ n ] optimally. 14 The most effective solution so far is the Long Short-Term Memory (LSTM) cell architecture [1] , [19] , [63] , [67] .
5. From RNN to vanilla LSTM network

The Long Short-Term Memory (LSTM) network was invented with the goal of addressing the vanishing gradients problem. They key insight in the LSTM design was to incorporate nonlinear, data-dependent controls into the RNN cell, which can be trained to ensure that the gradient of the objective function with respect to the state signal (the quantity directly proportional to the parameter updates computed during training by Gradient Descent) does not vanish  [1] . The LSTM cell can be rationalized from the canonical RNN cell by reasoning about Eq.  (30) and introducing changes that make the system robust and versatile.

In the RNN system, the observable readout signal of the cell is the warped version of the cell’s state signal itself. A weighted copy of this warped state signal is fed back from one step to the next as part of the update signal to the cell’s state. This tight coupling between the readout signal at one step and the state signal at the next step directly impacts the gradient of the objective function with respect to the state signal. This impact is compounded during the training phase, culminating in the vanishing/exploding gradients.

Several modifications to the cell’s design can be undertaken to remedy this situation. As a starting point, it is useful to separate the right hand side of Eq.  (30) (the cell’s updated state signal at a step with the index, n ) into two parts 15 : (94) s → [ n ] = F s → s → [ n − 1 ] + F u → r → [ n − 1 ] , x → [ n ] (95) r → [ n ] = G d ( s → [ n ] ) (96) F s → s → [ n − 1 ] = W s s → [ n − 1 ] (97) F u → r → [ n − 1 ] , x → [ n ] = W r r → [ n − 1 ] + W x x → [ n ] + θ → s where G d ( z → ) is the hyperbolic tangent as before. 16 The first part, F s → s → [ n − 1 ] , carries forward the contribution from the state signal at the previous step. The second part, F u → r → [ n − 1 ] , x → [ n ] , represents the update information, consisting of the combination of the readout signal from the previous step and the input signal (the external driving force) at the current step (plus the bias vector, θ → s ). 17 According to Eq.  (94) , the state signal blends both sources of information in equal proportions at every step. These proportions can be made adjustable by multiplying the two quantities by the special “gate” signals, g → c s [ n ] (“control state”) and g → c u [ n ] (“control update”), respectively: (98) s → [ n ] = g → c s [ n ] ⊙ F s → s → [ n − 1 ] + g → c u [ n ] ⊙ F u → r → [ n − 1 ] , x → [ n ] (99) 0 → ≤ g → c s [ n ] , g → c u [ n ] ≤ 1 → The elements of gate signals are non-negative fractions. The shorthand notation, g → [ n ] ∈ [ 0 → , 1 → ] (alternatively, 0 → ≤ g → [ n ] ≤ 1 → ), means that the values of all elements of a vector-valued gate signal, g → [ n ] , at a step with the index, n , lie on a closed segment between 0 and 1 .

    Download : Download high-res image (134KB)
    Download : Download full-size image 

Fig. 4 . Expanding the canonical RNN system by adding the “control state” gate, g → c s [ n ] , to control the amount of the state signal, retained from the previous step and the “control update” gate, g → c u [ n ] , to regulate the amount of the update signal — to be injected into the state signal at the current step.

The gate signals, g → c s [ n ] and g → c u [ n ] , in Eqs.  (98) , (99) provide a mechanism for exercising a fine-grained control of the two types of contributions to the state signal at every step. Specifically, g → c s [ n ] makes it possible to control the amount of the state signal, retained from the previous step, and g → c u [ n ] regulates the amount of the update signal — to be injected into the state signal at the current step. 18

    Download : Download high-res image (139KB)
    Download : Download full-size image 

Fig. 5 . The “control readout” gate, g → c r [ n ] , determines the fractional amount of the readout signal that becomes the cell’s observable value signal at the current step.

From the derivation of the standard RNN system in Section  2 , W s in Eq.  (96) is a diagonal matrix with positive fractions, 1 | a i i | , on its main diagonal. Hence, since the elements of g → c s [ n ] are also fractions, setting: (100) W s = I in g → c s [ n ] ⊙ W s is acceptable as long as the gate functions are parametrizable and their parameters are learned during training. Under these conditions, Eq.  (96) can be simplified to: (101) F s → s → [ n − 1 ] = s → [ n − 1 ] so that Eq.  (98) becomes: (102) s → [ n ] = g → c s [ n ] ⊙ F s → s → [ n − 1 ] + g → c u [ n ] ⊙ F u → r → [ n − 1 ] , x → [ n ] = g → c s [ n ] ⊙ s → [ n − 1 ] + g → c u [ n ] ⊙ F u → r → [ n − 1 ] , x → [ n ] Hence, the contribution from the state signal at the previous step remains fractional, insuring the stability of the overall system. Diagrammatically, the insertion of the expanded controls from Eq.  (102) into the canonical RNN system of Eq.  (30) transforms Fig. 1 into Fig. 4 .

While the update term, F u → r → [ n − 1 ] , x → [ n ] , as a whole is now controlled by g → c u [ n ] , the internal composition of F u → r → [ n − 1 ] , x → [ n ] itself needs to be examined. According to Eq.  (97) , the readout signal from the previous step and the input signal at the current step constitute the update candidate signal on every step with the index, n , with both of these terms contributing in equal proportions. The issue with always utilizing W r r → [ n − 1 ] in its entirety is that when g → c u [ n ] ∼ 1 , s → [ n − 1 ] and s → [ n ] become connected through W r and the warping function. Based on Eq.  (91) , this link constrains the gradient of the objective function with respect to the state signal, thus predisposing the system to the vanishing/exploding gradients problem. To throttle this feedback path, the readout signal, r → [ n ] , will be apportioned by another gate signal, g → c r [ n ] (“control readout”), as follows: (103) v → [ n ] = g → c r [ n ] ⊙ r → [ n ] (104) 0 → ≤ g → c r [ n ] ≤ 1 → The gating control, g → c r [ n ] , determines the fractional amount of the readout signal that becomes the cell’s observable value signal at the step with the index, n . Thus, using v → [ n − 1 ] in place of r → [ n ] in Eq.  (97) transforms it into: (105) F u → v → [ n − 1 ] , x → [ n ] = W r v → [ n − 1 ] + W x x → [ n ] + θ → s The RNN cell schematic diagram, expanded to accommodate the control readout gate, introduced in Eq.  (103) , and the modified recurrence relationship , employed in Eq.  (105) , appears in Fig. 5 .

Even though the external input does not affect the system’s stability or impact its susceptibility to vanishing/exploding gradients, pairing the input with its own “control input” gate makes the system more flexible.

Multiplying the external input signal, x → [ n ] , in Eq.  (97) by a dedicated gate signal, g → c x [ n ] , turns Eq.  (105) into: (106) F u → v → [ n − 1 ] , x → [ n ] = W r v → [ n − 1 ] + g → c x [ n ] ⊙ W x x → [ n ] + θ → s According to Eqs.  (103) , (106) , utilizing both the control readout gate, g → c r [ n ] , and the control input gate, g → c x [ n ] , allows for the update term, F u → v → [ n − 1 ] , x → [ n ] , to contain an arbitrary mix of the readout signal and the external input. The control input gate signal, g → c x [ n ] , will be later incorporated as part of extending the Vanilla LSTM cell. For now, it is assumed for simplicity that g → c x [ n ] = 1 → , so Eq.  (106) reduces to Eq.  (105) .

The dynamic range of the value signal of the cell, v → [ n ] , is determined by the readout signal, r → [ n ] , which is bounded by the warping nonlinearity , G d ( z ) . In order to maintain the same dynamic range while absorbing the contributions from the input signal, x → [ n ] (or g → c x [ n ] ⊙ x → [ n ] if the control input gate is part of the system architecture), the aggregate signal, F u → v → [ n − 1 ] , x → [ n ] , is tempered by the saturating warping nonlinearity, G d ( z ) , so as to produce the update candidate signal, u → [ n ] : (107) u → [ n ] = G d F u → v → [ n − 1 ] , x → [ n ] Thus, replacing the update term in Eq.  (102) with u → [ n ] , given by Eq.  (107) , finally yields 19 : (108) s → [ n ] = g → c s [ n ] ⊙ s → [ n − 1 ] + g → c u [ n ] ⊙ u → [ n ] which is a core constituent of the set of formulas defining the cell of the Vanilla LSTM network. According to Eq.  (108) , the state signal of the cell at the current step is a weighted combination of the state signal of the cell at the previous step and the aggregation of historical and novel update information available at the present step. The complete data path of the Vanilla LSTM cell, culminating from fortifying the canonical RNN system with gating controls and signal containment, is illustrated in Fig. 6 .

    Download : Download high-res image (146KB)
    Download : Download full-size image 

Fig. 6 . In the Vanilla LSTM network, the state signal of the cell at the current step is a weighted combination of the state signal of the cell at the previous step and the aggregation of historical and novel update information available at the present step.

Example 2

For an idealized illustration of the ability of the LSTM cell to propagate the error gradient unattenuated, set g → c s [ n ] to 1 → and both, g → c u [ n ] and g → c r [ n ] , to 0 → for all steps in the segment. Then s → [ n ] = s → [ n − 1 ] and ψ → [ n ] = ψ → [ n + 1 ] for all steps in the segment. The inventors of the LSTM network named this mode the “Constant Error Carousel” (CEC) to underscore that the error gradient is recirculated and the state signal of the cell is refreshed on every step. 20 Essentially, the multiplicative gate units open and close access to constant error gradient flow through CEC as part of the operation of the LSTM cell 21 [1] , [74] .

In Section  4 , we saw that the error gradient determines the parameter updates for training the standard RNN by Gradient Descent. It will become apparent in Section  6.9 that the same relationship holds for the Vanilla LSTM network as well. The difference is that because of the gates, the function for the error gradient of the LSTM network accommodates Gradient Descent better than that of the standard RNN does. As will be shown in Section  6.10 , under certain provisions regarding the model parameters, the unrolled Vanilla LSTM cell operates in the CEC mode. If such a parameter combination emerges during training, then the parameter update information, embedded in the error gradient signal, will be back-propagated over a large number of steps of a training subsequence, imparting sensitivity to the long-range dependencies to the model parameters through the parameter update step of Gradient Descent. If the training process steers the model parameters toward causing ‖ g → c s [ n ] ‖ = 1 (as in Example 2 ), then the LSTM network circumvents the vanishing gradient problem in this asymptotic case.

Analogously to the standard RNN, the Vanilla LSTM network, trained by Gradient Descent, can also learn the short-range dependencies among the samples of the subsequences, comprising the training data. Suppose that during training the model parameters cause ‖ g → c s [ n ] ‖ < 1 (unlike in Example 2 ). Then, as will be elaborated in Section  6.10 , the error gradient signal will decline, eventually vanishing over a finite number of steps, even if during training ‖ g → c u [ n ] ‖ > 0 and/or ‖ g → c r [ n ] ‖ > 0 so as to admit (by Eq.  (108) ) the contributions from the update candidate signal, u → [ n ] , into the composition of the state signal.

It remains to define the expressions for the gate signals, g → c s [ n ] , g → c r [ n ] , and g → c u [ n ] . Assuming that the system will be trained with BPTT, all of its constituent functions, including the functions for the gate signals, must be differentiable. A convenient function that is continuous, differentiable, monotonically increasing, and maps the domain ( − ∞ , ∞ ) into the range ( 0 , 1 ) is the logistic function : (109) G c ( z ) ≡ σ ( z ) ≡ 1 1 + e − z (110) = 1 + tanh ( z 2 ) 2 (111) = 1 + G d ( z 2 ) 2 which is a shifted, scaled, and re-parameterized replica of the hyperbolic tangent, used as the warping function, G d ( z ) , for the data signals in RNN and LSTM systems. When operating on vector arguments, G c ( z → ) is computed by applying Eq.  (109) to each element of the vector, z → , separately; the same rule applies to G d ( z → ) .

In order to determine the fractional values of the control signals, g → c s [ n ] , g → c u [ n ] , and g → c r [ n ] , at the step with the index, n , all the data signals, from as close as possible to the index of the current step, are utilized. Specifically, for both, g → c s [ n ] , which determines the fraction of the state signal, s → [ n − 1 ] , from the previous step and g → c u [ n ] , which determines the fraction of the update candidate signal, u → [ n ] , from the current step, the available data signals are s → [ n − 1 ] , v → [ n − 1 ] , and x → [ n ] . However, note that for g → c r [ n ] , which determines the fraction of the readout signal, r → [ n ] , from the current step, the available data signals are s → [ n ] , v → [ n − 1 ] , and x → [ n ] . This is because by Eq.  (103) , r → [ n ] is available at the junction of the cell, where g → c r [ n ] is computed, and hence, by Eq.  (95) , s → [ n ] is necessarily available. The input to each gate is presented as a linear combination of all the data signals available to it: (112) z → c s [ n ] = W x c s x → [ n ] + W s c s s → [ n − 1 ] + W v c s v → [ n − 1 ] + θ → c s (113) z → c u [ n ] = W x c u x → [ n ] + W s c u s → [ n − 1 ] + W v c u v → [ n − 1 ] + θ → c u (114) z → c r [ n ] = W x c r x → [ n ] + W s c r s → [ n ] + W v c r v → [ n − 1 ] + θ → c r Accumulating the available data signals linearly makes the application of the chain rule for BPTT straightforward, while providing a rich representation of the system’s data as an input to each gate at every step. As the model parameters, W x c r , W x c u , W x c s , W s c s , W v c s , θ → c s , W s c u , W v c u , θ → c u , W s c r , W v c r , θ → c r , in Eqs. (112) , (113) , and (114) are being trained, the gate functions, given by: (115) g → c s [ n ] = G c ( z → c s [ n ] ) (116) g → c u [ n ] = G c ( z → c u [ n ] ) (117) g → c r [ n ] = G c ( z → c r [ n ] ) become attuned to the flow of and the variations in the training data through the system at every step. During inference, this enables the gates to modulate their corresponding data signals adaptively, utilizing all the available information at every step. In particular, the gates help to detect and mitigate the detrimental ramifications of artificial boundaries, which arise in the input sequences, due to the implicit truncation, caused by unrolling  [75] , [76] , [77] . The gates make the LSTM system a robust model that compensates for the imperfections in the external data and is capable of generating high quality output sequences .

    Download : Download high-res image (250KB)
    Download : Download full-size image 

Fig. 7 . Vanilla LSTM network cell. The bias parameters, b → , have been omitted from the figure for brevity. They can be assumed to be included without the loss of generality by appending an additional element, always set to 1 , to the input signal vector, x → [ n ] , and increasing the row dimensions of all corresponding weight matrices by 1 .

This concludes the derivation of the Vanilla LSTM network. The next section presents a formal self-contained summary of the Vanilla LSTM system, including the equations for training it using BPTT.
6. The vanilla LSTM network mechanism in detail
6.1. Overview

Suppose that an LSTM cell is unrolled for K steps. The LSTM cell at the step with the index, n (in the sequence of K steps), accepts the input signal, x → [ n ] , and computes the externally-accessible (i.e., observable) signal, v → [ n ] . The internal state signal of the cell at the step with the index, n , is maintained in s → [ n ] , which is normally not observable by entities external to the cell. 22 However, the computations, associated with the cell at the next adjacent step in the increasing order of the index, n (i.e., the LSTM step at the index, n + 1 ), are allowed to access s → [ n ] , the state signal of the LSTM cell at the step with the index, n .

The key principle of the LSTM cell centers around organizing its internal operations according to two qualitatively different, yet cooperating, objectives: data and the control of data. The data components prepare the candidate data signals (ranging between − 1 and 1 ), while the control components prepare the “throttle” signals (ranging between 0 and 1 ). Multiplying the candidate data signal by the control signal apportions the fractional amount of the candidate data that is allowed to propagate to its intended nodes in the cell. Hence, if the control signal is 0 , then 0 % of the candidate data amount will propagate. Conversely, if the control signal is 1, then 10 0 % of the candidate data amount will propagate. Analogously, for intermediate values of the control signal (in the range between 0 and 1 ), the corresponding percentage of the candidate data amount will be made available to the next function in the cell.

As depicted in Fig. 7 , the Vanilla LSTM cell contains three candidate-data/control stages: update, state, and readout.
6.2. Notation

The following notation is used consistently throughout this section to define the Vanilla LSTM cell:

    •

    n — index of a step in the segment (or subsequence); n = 0 , … , K − 1
    •

    K — number of steps in the unrolled segment (or subsequence)
    •

    G c — monotonic, bipolarly-saturating warping function for control/throttling purposes (acts as a “gate”)
    •

    G d — monotonic, negative-symmetric, bipolarly-saturating warping function for data bounding purposes
    •

    d x — dimensionality of the input signal to the cell
    •

    d s — dimensionality of the state signal of the cell
    •

    x → ∈ R d x — the input signal to the cell
    •

    s → ∈ R d s — the state signal of the cell
    •

    v → ∈ R d s — the observable value signal of the cell for external purposes (e.g., for connecting one step to the next adjacent step of the same cell in the increasing order of the step index, n ; as input to another cell in the cascade of cells; for connecting to the signal transformation filter for data output; etc.)
    •

    a → ∈ R d s — an accumulation node of the cell (linearly combines the signals from the preceding step and the present step as net input to a warping function at the present step; each cell contains several purpose-specific control and data accumulation nodes)
    •

    u → ∈ R d s — the update candidate signal for the state signal of the cell
    •

    r → ∈ R d s — the readout candidate signal of the cell
    •

    g ∈ R d s — a gate output signal of the cell for control/throttling purposes
    •

    E ∈ R — objective (cost) function to be minimized as part of the model training procedure
    •

    x → T v → — vector–vector inner product (yields a scalar)
    •

    x → v → T — vector–vector outer product (yields a matrix)
    •

    W v → — matrix–vector product (yields a vector)
    •

    x → ⊙ v → — element-wise vector product (yields a vector)

6.3. Control/throttling (“gate”) nodes

The Vanilla LSTM cell uses three gate types:

    •

    control of the fractional amount of the update candidate signal used to comprise the state signal of the cell at the present step with the index, n
    •

    control of the fractional amount of the state signal of the cell at the adjacent lower-indexed step, n − 1 , used to comprise the state signal of the cell at the present step with the index,  n
    •

    control of the fractional amount of the readout candidate signal used to release as the externally-accessible (observable) signal of the cell at the present step with the index,  n

6.4. Data set standardization

Before the operation of the LSTM network (or its parent, RNN) can commence, the external training data set, x → 0 [ n ] , needs to be standardized, such that all elements of the input to the network, x → [ n ] , have the mean of 0 and the standard deviation of 1 over the training set: (118) μ → = 1 N ∑ n = 0 N − 1 x → 0 [ n ] (119) V = 1 N − 1 ∑ n = 0 N − 1 x → 0 [ n ] − μ → x → 0 [ n ] − μ → T (120) x → [ n ] = d i a g V i i − 1 x → 0 [ n ] − μ → Applying the transformations in Eqs.  (118) , (119) , and  (120) to the external training samples, x → 0 [ n ] , accomplishes this task. In these equations, N is the number of samples in the training set, μ → is the sample mean, and V is the sample auto-covariance matrix of the training set. 23
6.5. Warping (activation) functions

As described in Section  6.1 , the warping function for control needs to output a value between 0 and 1 . The sigmoidal (also known as “logistic”) nonlinearity is a good choice , because it is bipolarly-saturating between these values and is monotonic, continuous, and differentiable: (121) G c ( z ) ≡ σ ( z ) ≡ 1 1 + e − z = 1 + tanh ( z 2 ) 2 = 1 + G d ( z 2 ) 2 Related to this function, the hyperbolic tangent is a suitable choice for the warping function for data bounding purposes: (122) G d ( z ) ≡ tanh ( z ) = e z − e − z e z + e − z = 2 σ ( 2 z ) − 1 = 2 G c ( 2 z ) − 1 because it is monotonic, negative-symmetric, and bipolarly-saturating at − 1 and 1 (i.e., one standard deviation of x → [ n ] in each direction). This insures that the data warping function, G d ( z ) , will support both negative and positive values of the standardized incoming data signal, x → [ n ] , in Eq.  (120) , and keep it bounded within that range (the “squashing” property).
6.6. Vanilla LSTM cell model parameters

The Vanilla LSTM cell model uses the following fifteen (15) parameter entities (with their respective dimensions and designations as indicated below):
6.6.1. Parameters of the accumulation node, a → c u [ n ] , of the gate that controls the fractional amount of the update candidate signal, u → [ n ] , used to comprise the state signal of the cell at the present step with the index, n

    •

    W x c u ∈ R d s × d x — the matrix of weights connecting the input signal, x → [ n ] , at the present step with the index, n , to the “control update” accumulation node, a → c u [ n ] , of the cell at the present step with the index, n
    •

    W s c u ∈ R d s × d s — the matrix of weights connecting the state signal, s → [ n − 1 ] , at the adjacent lower-indexed step with the index, n − 1 , to the “control update” accumulation node, a → c u [ n ] , of the cell at the present step with the index, n
    •

    W v c u ∈ R d s × d s — the matrix of weights connecting the externally-accessible (observable) value signal, v → [ n − 1 ] , at the adjacent lower-indexed step with the index, n − 1 , to the “control update” accumulation node, a → c u [ n ] , of the cell at the present step with the index, n
    •

    b → c u ∈ R d s — the vector of bias elements for the “control update” accumulation node, a → c u [ n ] , of the cell at the present step with the index, n

6.6.2. Parameters of the accumulation node, a → c s [ n ] , of the gate that controls the fractional amount of the state signal of the cell, s → [ n − 1 ] , at the adjacent lower-indexed step, n − 1 , used to comprise the state signal of the cell at the present step with the index, n

    •

    W x c s ∈ R d s × d x — the matrix of weights connecting the input signal, x → [ n ] , at the present step with the index, n , to the “control state” accumulation node, a → c s [ n ] , of the cell at the present step with the index, n
    •

    W s c s ∈ R d s × d s — the matrix of weights connecting the state signal, s → [ n − 1 ] , at the adjacent lower-indexed step with the index, n − 1 , to the “control state” accumulation node, a → c s [ n ] , of the cell at the present step with the index, n
    •

    W v c s ∈ R d s × d s — the matrix of weights connecting the externally-accessible (observable) value signal, v → [ n − 1 ] , at the adjacent lower-indexed step with the index, n − 1 , to the “control state” accumulation node, a → c s [ n ] , of the cell at the present step with the index, n
    •

    b → c s ∈ R d s — the vector of bias elements for the “control state” accumulation node, a → c s [ n ] , of the cell at the present step with the index, n

6.6.3. Parameters of the accumulation node, a → c r [ n ] , of the gate that controls the fractional amount of the readout candidate signal, r → [ n ] , used to release as the externally-accessible (observable) value signal of the cell at the present step with the index, n

    •

    W x c r ∈ R d s × d x — the matrix of weights connecting the input signal, x → [ n ] , at the present step with the index, n , to the “control readout” accumulation node, a → c r [ n ] , of the cell at the present step with the index, n
    •

    W s c r ∈ R d s × d s — the matrix of weights connecting the state signal, s → [ n ] , at the present step with the index, n , to the “control readout” accumulation node, a → c r [ n ] , of the cell at the present step with the index, n
    •

    W v c r ∈ R d s × d s — the matrix of weights connecting the externally-accessible (observable) value signal, v → [ n − 1 ] , at the adjacent lower-indexed step with the index, n − 1 , to the “control readout” accumulation node, a → c r [ n ] , of the cell at the present step with the index, n
    •

    b → c r ∈ R d s — the vector of bias elements for the “control readout” accumulation node, a → c r [ n ] , of the cell at the present step with the index, n

6.6.4. Parameters of the accumulation node, a → d u [ n ] , for the data warping function that produces the update candidate signal, u → [ n ] , of the cell at the present step with the index, n

    •

    W x d u ∈ R d s × d x — the matrix of weights connecting the input signal, x → [ n ] , at the present step with the index, n , to the “data update” accumulation node, a → d u [ n ] , of the cell at the present step with the index, n
    •

    W v d u ∈ R d s × d s — the matrix of weights connecting the externally-accessible (observable) value signal, v → [ n − 1 ] , at the adjacent lower-indexed step with the index, n − 1 , to the “data update” accumulation node, a → d u [ n ] , of the cell at the present step with the index, n
    •

    b → d u ∈ R d s — the vector of bias elements for the “data update” accumulation node, a → d u [ n ] , of the cell at the present step with the index, n

6.6.5. All model parameters, which must be learned, combined (for notational convenience)

    •

    All parameters of the LSTM network are commonly concatenated and represented as a whole by Θ : (123) Θ ≡ W x c u , W s c u , W v c u , b → c u , W x c s , W s c s , W v c s , b → c s , W x c r , W s c r , W v c r , b → c r W x d u , W v d u , b → d u
    •

    Arranged “thematically” (attributed by the type of an accumulation), Θ can be written as: (124) Θ ≡

6.7. Summary of the main entities (generalized)

The following glossary lists the main entities of the model in a generalized way (i.e., without the subscripts, indices, etc.). Note that the special quantities ψ , → χ → , α → , ρ → , γ → will be defined in Section  6.9 . (125) x → ∈ R d x s → , v → , a → , u → , r → , g → ∈ R d s ψ → , χ → , α → , ρ → , γ → ∈ R d s W x ∈ R d s × d x W s , W v ∈ R d s × d s b → ∈ R d s E N K n = 0 , … , K − 1
6.8. Vanilla LSTM system equations (“forward pass”)

It is important to highlight the general pattern of computations that govern the processes, according to which any RNN cell, and the LSTM network cell in particular, unrolled for K steps, generates sequences of samples. Namely, the quantities that characterize the step of the cell at the index, n , of the sequence depend on the quantities that characterize the step of the cell at the index, n − 1 , of the sequence. 24 The following equations fully define the Vanilla LSTM cell: (126) a → c u [ n ] = W x c u x → [ n ] + W s c u s → [ n − 1 ] + W v c u v → [ n − 1 ] + b → c u (127) a → c s [ n ] = W x c s x → [ n ] + W s c s s → [ n − 1 ] + W v c s v → [ n − 1 ] + b → c s (128) a → c r [ n ] = W x c r x → [ n ] + W s c r s → [ n ] + W v c r v → [ n − 1 ] + b → c r (129) a → d u [ n ] = W x d u x → [ n ] + W v d u v → [ n − 1 ] + b → d u (130) u → [ n ] = G d ( a → d u [ n ] ) (131) g → c u [ n ] = G c ( a → c u [ n ] ) (132) g → c s [ n ] = G c ( a → c s [ n ] ) (133) g → c r [ n ] = G c ( a → c r [ n ] ) (134) s → [ n ] = g → c s [ n ] ⊙ s → [ n − 1 ] + g → c u [ n ] ⊙ u → [ n ] (135) r → [ n ] = G d ( s → [ n ] ) (136) v → [ n ] = g → c r [ n ] ⊙ r → [ n ] The schematic diagram of the Vanilla LSTM cell, defined by Eqs.  (126) – (136) , is presented in Fig. 7 , and the snapshot of unrolling it (for only 4 steps as an illustration) appears in Fig. 8 . In order to make it easier to isolate the specific functions performed by the components of the Vanilla LSTM cell, its schematic diagram is redrawn in Fig. 9 , with the major stages comprising the cell’s architecture marked by dashed rectangles annotated by the names of the respective enclosed stages.

    Download : Download high-res image (106KB)
    Download : Download full-size image 

Fig. 8 . Sequence of steps generated by unrolling a cell of the LSTM network (displaying 4 steps for illustration).

    Download : Download high-res image (376KB)
    Download : Download full-size image 

Fig. 9 . Vanilla LSTM network cell from Fig. 7 , with the stages of the system delineated by dashed rectangles and annotations that depict the function of each stage. As before, the bias parameters, b → , have been omitted from the figure for brevity. (They can be assumed to be included without the loss of generality by appending an additional element, always set to 1 , to the input signal vector, x → [ n ] , and increasing the row dimensions of all corresponding weight matrices by 1 .).
6.9. Vanilla LSTM system derivatives (“backward pass”)

This section derives the equations that are necessary for training the Vanilla LSTM network cell, unrolled for K steps, using Back Propagation Through Time (BPTT). To obtain the update equations for the parameters of the system, two auxiliary “backward-moving” gradient sequences, indexed by n , are computed first: χ → [ n ] , the total partial derivative of the objective function, E , with respect to the externally-accessible (observable) value signal, v → [ n ] , and ψ → [ n ] , the total partial derivative of the objective function, E , with respect to the state signal, s → [ n ] . The decision to “anchor” the chain rule at the border of the cell is made judiciously, guided by the principles of modular design. Expressing every intra-cell total partial derivative in terms of χ → [ n ] (instead of explicitly computing the total partial derivative of the objective function, E , with respect to each variable of the cell [28] ) reduces the number of intermediate variables. This makes the equations for the backward pass straightforward and a natural fit for an implementation as a pluggable module  [19] , [64] , [65] .

Due to the backward-moving recursion of χ → [ n ] and ψ → [ n ] (the gradient sequences propagate in the direction opposite to that of the state signal, s → [ n ] , as a function of the step index, n ), the values of χ → [ n ] and ψ → [ n ] at the index, n , depend on the values of the same quantities at the index, n + 1 , subject to the initial conditions. Once χ → [ n ] and ψ → [ n ] are known, they are used to compute the total partial derivatives of the objective function, E , with respect to the accumulation nodes for each value of the index, n . These intermediate gradient sequences, named α → c s [ n ] , α → c u [ n ] , α → c r [ n ] , and α → d u [ n ] , allocate the amounts contributed by the signals associated with the step at the index, n , to the total partial derivatives of the objective function, E , with respect to the model parameters. By the definition of the total derivative, these contributions have to be summed across all steps, 0 ≤ n ≤ K − 1 , to produce the total partial derivatives of the objective function, E , with respect to the model parameters.

During the inference phase of the LSTM system, only x → [ n ] (the input signal) and v → [ n ] (the value signal) are externally accessible (i.e., observable). The cell accepts the input signal at each step and computes the value signal for all steps. All the other intermediate signals are available only to the internal components and nodes of the cell, with the exception of s → [ n ] (state signal) and v → [ n ] (value signal), which serve both the inter- and the intra-step purposes throughout the unrolled sequence.

The cell’s value signal, v → [ n ] , at the step with the index, n , can be further transformed to produce the output signal, y → [ n ] (e.g., a commonly used form of y → [ n ] may be obtained by computing a linear transformation of v → [ n ] , followed by a softmax operator, or a different decision function). Likewise, the input signal, too, may result from the transformation of the original raw data. For example, one kind of input pre-processing can convert the vocabulary “one-hot” vector into a more compact representation. Also, for applications where the input data set can be collected for the entire segment at once, input samples that lie within a small window surrounding the given step can be combined so as to enhance the system’s “attention” to context. A non-causal input filter, designed for this purpose, will be introduced in Section  7.1 as part of extending the Vanilla LSTM cell.

We start by computing the derivatives of the warping functions from their definitions in Eqs.  (121) , (122) , respectively: (137) d G c ( z ) d z = G c ( z ) ( 1 − G c ( z ) ) (138) d G d ( z ) d z = 1 − ( G d ( z ) ) 2 Next, we anchor the chain rule at the border of the cell by defining χ → [ n ] as the total partial derivative of the objective function, E , with respect to the externally-accessible (observable) value signal, v → [ n ] , as follows: (139) χ → [ n ] ≡ ∇ → v → [ n ] E = ∂ E ∂ v → [ n ] As will become imminently evident, having χ → [ n ] not only makes training equations for the Vanilla LSTM cell amenable for a modular implementation at the step level, but also greatly simplifies them.

We also define the total partial derivatives of the objective function, E , with respect to three intermediate (i.e., away from the border) variables and another border variable of the Vanilla LSTM cell: (140) ρ → [ n ] ≡ ∇ → r → [ n ] E = ∂ E ∂ r → [ n ] (141) γ → [ n ] ≡ ∇ → g → [ n ] E = ∂ E ∂ g → [ n ] (142) α → [ n ] ≡ ∇ → a → [ n ] E = ∂ E ∂ a → [ n ] (143) ψ → [ n ] ≡ ∇ → s → [ n ] E = ∂ E ∂ s → [ n ] The border quantity in Eq.  (143) , ψ → [ n ] , is of special significance as it is the total partial derivative of the objective function, E , with respect to the state signal, s → [ n ] , at the index, n , of the Vanilla LSTM cell. As in the standard RNN, all parameter updates in the Vanilla LSTM network depend on ψ → [ n ] , making it the most important error gradient sequence of the system.

The backward pass equations are obtained by utilizing these border and intermediate derivatives in the application of the chain rule to the Vanilla LSTM cell, defined by Eqs.  (126) – (136) : (144) χ → [ n ] = ∂ y → [ n ] ∂ v → [ n ] T ∂ E ∂ y → [ n ] + f χ → [ n + 1 ] (145) ρ → [ n ] = ∂ v → [ n ] ∂ r → [ n ] T ∂ E ∂ v → [ n ] = ( ∇ → v → [ n ] E ) ⊙ g → c r [ n ] = χ → [ n ] ⊙ g → c r [ n ] (146) γ → c r [ n ] = ∂ E ∂ v → [ n ] ∂ v → [ n ] ∂ g → c r [ n ] = ( ∇ → v → [ n ] E ) ⊙ r → [ n ] = χ → [ n ] ⊙ r → [ n ] (147) α → c r [ n ] = γ → c r [ n ] ⊙ ∂ g → c r [ n ] ∂ a → c r [ n ] = γ → c r [ n ] ⊙ d G c ( z ) d z ⌋ z = a → c r [ n ] = χ → [ n ] ⊙ r → [ n ] ⊙ d G c ( z ) d z ⌋ z = a → c r [ n ] (150) ψ → [ n ] = ρ → [ n ] ⊙ ∂ r → [ n ] ∂ s → [ n ] + ∂ a → c r [ n ] ∂ s → [ n ] α → c r [ n ] + f ψ → [ n + 1 ] = ρ → [ n ] ⊙ d G d ( z → ) d z → ⌋ z = s → [ n ] + W s c r α → c r [ n ] + f ψ → [ n + 1 ] = χ → [ n ] ⊙ g → c r [ n ] ⊙ d G d ( z → ) d z → ⌋ z = s → [ n ] + W s c r α → c r [ n ] + f ψ → [ n + 1 ] (151) α → c s [ n ] = ψ → [ n ] ⊙ ∂ s → [ n ] ∂ g → c s [ n ] ⊙ ∂ g → c s [ n ] ∂ a → c s [ n ] = ψ → [ n ] ⊙ s → [ n − 1 ] ⊙ d G c ( z → ) d z → ⌋ z = a → c s [ n ] (152) α → c u [ n ] = ψ → [ n ] ⊙ ∂ s → [ n ] ∂ g → c u [ n ] ⊙ ∂ g → c u [ n ] ∂ a → c u [ n ] = ψ → [ n ] ⊙ u → [ n ] ⊙ d G c ( z → ) d z → ⌋ z = a → c u [ n ] (153) α → d u [ n ] = ψ → [ n ] ⊙ ∂ s → [ n ] ∂ u → [ n ] ⊙ d G d ( z → ) d z → ⌋ z = a → d u [ n ] = ψ → [ n ] ⊙ g → c u [ n ] ⊙ d G d ( z → ) d z → ⌋ z = a → d u [ n ] where: (154) f χ → [ n + 1 ] = W v c u α → c u [ n + 1 ] + W v c s α → c s [ n + 1 ] + W v c r α → c r [ n + 1 ] + W v d u α → d u [ n + 1 ] (155) f ψ → [ n + 1 ] = W s c u α → c u [ n + 1 ] + W s c s α → c s [ n + 1 ] + g → c s [ n + 1 ] ⊙ ψ → [ n + 1 ] are the portions of the total derivative of the objective function, E , with respect to the cell’s value signal and the cell’s state signal, respectively, contributed by the quantities evaluated at the step with the index, n + 1 .

The total partial derivatives of the objective function, E , with respect to the model parameters at the step with the index, n , are directly proportional to the “accumulation derivatives”, 25 given by Eqs. (147) , (151) , (152) , and Eq.  (153) . Hence, by referring once again to the definition of the Vanilla LSTM cell in Eqs.  (126) – (136) , we obtain: (156) ∂ E ∂ W x c u [ n ] = α → c u [ n ] x → T [ n ] (157) ∂ E ∂ W s c u [ n ] = α → c u [ n ] s → T [ n − 1 ] (158) ∂ E ∂ W v c u [ n ] = α → c u [ n ] v → T [ n − 1 ] (159) ∂ E ∂ b → c u [ n ] = α → c u [ n ] (160) ∂ E ∂ W x c s [ n ] = α → c s [ n ] x → T [ n ] (161) ∂ E ∂ W s c s [ n ] = α → c s [ n ] s → T [ n − 1 ] (162) ∂ E ∂ W v c s [ n ] = α → c s [ n ] v → T [ n − 1 ] (163) ∂ E ∂ b → c s [ n ] = α → c s [ n ] (164) ∂ E ∂ W x c r [ n ] = α → c r [ n ] x → T [ n ] (165) ∂ E ∂ W s c r [ n ] = α → c r [ n ] s → T [ n ] (166) ∂ E ∂ W v c r [ n ] = α → c r [ n ] v → T [ n − 1 ] (167) ∂ E ∂ b → c r [ n ] = α → c r [ n ] (168) ∂ E ∂ W x d u [ n ] = α → d u [ n ] x → T [ n ] (169) ∂ E ∂ W v d u [ n ] = α → d u [ n ] v → T [ n − 1 ] (170) ∂ E ∂ b → d u [ n ] = α → d u [ n ] Arranged congruently with Eq.  (124) , the total partial derivative of the objective function, E , with respect to the model parameters, Θ , at the step with the index, n , is: (171) ∂ E ∂ Θ [ n ] = When the Vanilla LSTM cell is unrolled for K steps in order to cover one full segment of training samples, the same set of the model parameters, Θ , is shared by all the steps. This is because Θ is the parameter of the Vanilla LSTM cell as a whole. Consequently, the total derivative of the objective function, E , with respect to the model parameters, Θ , has to include the contributions from all steps of the unrolled sequence: (172) d E d Θ = ∑ n = 0 K − 1 ∂ E ∂ Θ [ n ] The result from Eq.  (172) can now be used as part of optimization by Gradient Descent. In practice, Eq.  (172) is computed for a batch of segments, 26 and the sum of the parameter gradients over all segments in the batch is then supplied to the Gradient Descent algorithm for updating the model parameters. 27
6.10. Error gradient sequences in vanilla LSTM system

Section  5 mentions that because of the action of the gates, the LSTM network is more compatible with the Gradient Descent training procedure than the standard RNN system is. As discussed in Sections  4 RNN training difficulties , 6.9 Vanilla LSTM system derivatives (“backward pass”) , for Gradient Descent to be effective, the elements of ∂ E ∂ Θ [ n ] in Eq.  (171) must be well-behaved numerically. In particular, this implies that the intermediate gradient sequences, α → c s [ n ] , α → c u [ n ] , α → c r [ n ] , and α → d u [ n ] , and hence the border gradient sequences, χ → [ n ] and ψ → [ n ] , must be able to sustain a steady flow of information over long ranges of the step index, n . Expanding Eq.  (150) produces: (173) ψ → [ n ] = χ → [ n ] ⊙ g → c r [ n ] ⊙ d G d ( z → ) d z → ⌋ z = s → [ n ] + W s c r χ → [ n ] ⊙ r → [ n ] ⊙ d G c ( z ) d z ⌋ z = a → c r [ n ] + f ψ → [ n + 1 ] (174) = ∂ y → [ n ] ∂ v → [ n ] T ∂ E ∂ y → [ n ] + f χ → [ n + 1 ] ⊙ g → c r [ n ] ⊙ d G d ( z → ) d z → ⌋ z = s → [ n ] + W s c r ∂ y → [ n ] ∂ v → [ n ] T ∂ E ∂ y → [ n ] + f χ → [ n + 1 ] ⊙ r → [ n ] ⊙ d G c ( z ) d z ⌋ z = a → c r [ n ] + f ψ → [ n + 1 ] According to Eqs.  (154) , (155) , both χ → [ n ] and ψ → [ n ] depend on ψ → [ n + 1 ] . Hence, we can follow the approach in Section  4 to analyze the dependence of ψ → [ n ] on ψ → [ k ] n < k ≤ K − 1 in order to gauge the sensitivity of the LSTM system to factors conducive to gradient decay. Applying the change of indices, n ⟶ k − 1 , and the chain rule to Eq.  (174) yields 28 : (175) ∂ ψ → [ k − 1 ] ∂ ψ → [ k ] = ∂ ψ → [ k − 1 ] ∂ f χ → [ k ] ∂ f χ → [ k ] ∂ ψ → [ k ] + ∂ ψ → [ k − 1 ] ∂ f ψ → [ k ] ∂ f ψ → [ k ] ∂ ψ → [ k ] (176) = ∂ ψ → [ k − 1 ] ∂ f χ → [ k ] ∂ f χ → [ k ] ∂ α → c u [ k ] ∂ α → c u [ k ] ∂ ψ → [ k ] + ∂ f χ → [ k ] ∂ α → c s [ k ] ∂ α → c s [ k ] ∂ ψ → [ k ] + ∂ f χ → [ k ] ∂ α → d u [ k ] ∂ α → d u [ k ] ∂ ψ → [ k ] + ∂ ψ → [ k − 1 ] ∂ f ψ → [ k ] ∂ f ψ → [ k ] ∂ α → c u [ k ] ∂ α → c u [ k ] ∂ ψ → [ k ] + ∂ f ψ → [ k ] ∂ α → c s [ k ] ∂ α → c s [ k ] ∂ ψ → [ k ] + diag [ g → c s [ k ] ] (177) = diag g → c r [ k − 1 ] ⊙ d G d ( z → ) d z → ⌋ z = s → [ k − 1 ] + W s c r diag r → [ k − 1 ] ⊙ d G c ( z ) d z ⌋ z = a → c r [ k − 1 ] × W v c u diag u → [ k ] ⊙ d G c ( z → ) d z → ⌋ z = a → c u [ k ] + W v c s diag s → [ k − 1 ] ⊙ d G c ( z → ) d z → ⌋ z = a → c s [ k ] + W v d u diag g → c u [ k ] ⊙ d G d ( z → ) d z → ⌋ z = a → d u [ k ] + W s c u diag u → [ k ] ⊙ d G c ( z → ) d z → ⌋ z = a → c u [ k ] + W s c s diag s → [ k − 1 ] ⊙ d G c ( z → ) d z → ⌋ z = a → c s [ k ] + diag [ g → c s [ k ] ] (178) = diag u → [ k ] ⊙ d G c ( z → ) d z → ⌋ z = a → c u [ k ] × W v c u diag g → c r [ k − 1 ] ⊙ d G d ( z → ) d z → ⌋ z = s → [ k − 1 ] W s c r diag r → [ k − 1 ] ⊙ d G c ( z ) d z ⌋ z = a → c r [ k − 1 ] + W s c u + diag s → [ k − 1 ] ⊙ d G c ( z → ) d z → ⌋ z = a → c s [ k ] × W v c s diag g → c r [ k − 1 ] ⊙ d G d ( z → ) d z → ⌋ z = s → [ k − 1 ] + W s c r diag r → [ k − 1 ] ⊙ d G c ( z ) d z ⌋ z = a → c r [ k − 1 ] + W s c s + diag g → c u [ k ] ⊙ d G d ( z → ) d z → ⌋ z = a → d u [ k ] × W v d u diag g → c r [ k − 1 ] ⊙ d G d ( z → ) d z → ⌋ z = s → [ k − 1 ] + W s c r diag r → [ k − 1 ] ⊙ d G c ( z ) d z ⌋ z = a → c r [ k − 1 ] + diag [ g → c s [ k ] ] (179) = Q k − 1 , k ; Θ ̃ + diag [ g → c s [ k ] ] where Θ ̃ = W s c u , W v c u , W s c s , W v c s , W s c r , W v d u , and Q k − 1 , k ; Θ ̃ subsumes all the terms in ∂ ψ → [ k − 1 ] ∂ ψ → [ k ] , excluding diag [ g → c s [ k ] ] .

Extrapolating ∂ ψ → [ k − 1 ] ∂ ψ → [ k ] from the step with the index, n , to the step with the index, l ≤ K − 1 , where l ≫ n , gives: (180) ∂ ψ → [ n ] ∂ ψ → [ l ] = ∏ k = n + 1 l ∂ ψ → [ k − 1 ] ∂ ψ → [ k ]

Assuming that the issue of “exploding gradients” is handled as a separate undertaking, the present focus is on the effectiveness of the LSTM network at assuaging the “vanishing gradients” problem. If the value of the total partial derivative of the objective function, E , with respect to the state signal, s → [ l ] , at the index, l ≤ K − 1 , where l ≫ n , is considered to be an impulse of the error gradient, then Eq.  (180) computes the fractional amount of this corrective stimulus that did not dissipate across the large number ( l − n ) of steps and is preserved in ψ → [ n ] , thereby able to contribute to updating the model parameters.

The propensity of the LSTM system toward diminishing error gradients during training can be assessed by evaluating the different modes of Eq.  (179) that can cause ‖ ∂ ψ → [ n ] ∂ ψ → [ l ] ‖ ≈ 0 in Eq.  (180) when l − n is large. A sufficient condition for driving the residual ‖ ∂ ψ → [ n ] ∂ ψ → [ l ] ‖ to zero is maintaining ‖ ∂ ψ → [ k − 1 ] ∂ ψ → [ k ] ‖ < 1 at each step with the index, k . There are three possibilities for this outcome:

    •

    Q k − 1 , k ; Θ ̃ = [ 0 ] and g → c s [ k ] = 0 → for all values of the step index, k . This is the case of the network being perpetually “at rest” (i.e., in a trivial state), which is not interesting from the practical standpoint.
    •

    g → c s [ k ] ≈ 1 → and Q k − 1 , k ; Θ ̃ = − diag [ g → c s [ k ] ] ; in other words, Q k − 1 , k ; Θ ̃ and diag [ g → c s [ k ] ] “cancel each other out” for some value of the step index, k . However, satisfying this condition would require a very careful orchestration of all signals, which is highly unlikely to occur in practice, making this pathological case unrealistic.
    •

    The spectral radius of Q k − 1 , k ; Θ ̃ + diag [ g → c s [ k ] ] in Eq.  (179) is less than unity for all values of the step index, k . In this situation, the error gradient will degrade to negligible levels after a sufficiently large number of steps. Nevertheless, this behavior would not be due to a degenerate mode of the system, but as a consequence of the particular patterns, occurring in the training data. In other words, some dependencies are naturally short-range.

For all remaining cases, the magnitude of ∂ ψ → [ k − 1 ] ∂ ψ → [ k ] is governed by the triangle inequality : (181) ‖ ∂ ψ → [ k − 1 ] ∂ ψ → [ k ] ‖ ≤ ‖ Q k − 1 , k ; Θ ̃ ‖ + ‖ diag [ g → c s [ k ] ] ‖ The most emblematic regime of the LSTM network arises when ‖ Q k − 1 , k ; Θ ̃ ‖ < 1 . Examining the terms in Eq.  (178) exposes multiple ways of restricting signals and parameters that would create favorable circumstances for this to hold. The following list prescribes several plausible alternatives (all conditions in each arrangement must be satisfied) 29 :

    •

    ‖ W s c u ‖ < 1 2 , ‖ W v c u ‖ < 1 2 , ‖ W s c s ‖ < 1 2 , ‖ W v c s ‖ < 1 2 , ‖ W v d u ‖ < 1
    •

    the state signal saturates the readout data warping function, ‖ W s c r ‖ < 1 2 , ‖ W s c u ‖ < 1 2 , ‖ W s c s ‖ < 1 2
    •

    the state signal saturates the readout data warping function, the accumulation signal for the control readout gate saturates its control warping function, ‖ W s c u ‖ < 1 2 , ‖ W s c s ‖ < 1 2
    •

    the control readout gate is turned off, ‖ W s c u ‖ < 1 2 , ‖ W s c s ‖ < 1 2
    •

    the accumulation signals for the control update gate and the control state gate saturate their respective control warping functions, the update candidate accumulation signal saturates the update candidate data warping function
    •

    the control update gate is turned off, the control state gate is turned off

Since the difference between the step indices, l − n , is large when the network is trained to represent long-range dependencies, the powers of the Q k − 1 , k ; Θ ̃ terms become negligible, ultimately leading to: (182) ‖ ∂ ψ → [ n ] ∂ ψ → [ l ] ‖ ∼ ∏ k = n + 1 l ‖ diag [ g → c s [ k ] ] ‖ ⩽ 1

Unlike Q k − 1 , k ; Θ ̃ , diag [ g → c s [ k ] ] in Eq.  (179) has no attenuating factors (the multiplier of g → c s [ n + 1 ] ⊙ ψ → [ n + 1 ] in Eq.  (155) is the identity matrix). As long as the elements of g → c s [ n ] are fractions, the error gradient will naturally decay. However, if the model is trained to saturate g → c s [ n ] at 1 → , then the error gradient is recirculated through Constant Error Carousel.
7. Extensions to the Vanilla LSTM network

Since its invention, many variants and extensions of the original LSTM network model have been researched and utilized in practice. In this section, we will evolve the Vanilla LSTM architecture, derived in Section  5 and explained in depth in Section  6 , along three avenues. Based on the analysis in Section  2 as well as the discussions in Sections  5 From RNN to vanilla LSTM network , 6.9 Vanilla LSTM system derivatives (“backward pass”) , we will expand the input from consisting of a single sample to combining multiple samples within a small context window. In addition, as proposed in Section  5 , we will introduce a new gate for controlling this richer input signal. Besides these two novel extensions, we will also include the “recurrent projection layer” in the augmented model, because it proved to be advantageous in certain sequence modeling applications  [24] .
7.1. External input context windows

We will represent the external input context windows by linear filters that have matrix-valued coefficients and operate on the sequence of input samples along the dimension of the steps of the sequence produced by unrolling the LSTM cell. In Eqs.  (126) – (129) , the matrix–vector products, W x c u x → [ n ] , W x c s x → [ n ] , W x c r x → [ n ] , and W x d u x → [ n ] , respectively, which involve a single input sample, x → [ n ] , will be replaced by the convolutions of the context window filters, W x c u [ n ] , W x c s [ n ] , W x c r [ n ] , and W x d u [ n ] , respectively, with the input signal, x → [ n ] , thereby involving all input samples within the context window in the computation of the respective accumulation signal. We choose the context window filters to be non-causal (i.e., with the non-zero coefficients defined only for n ≤ 0 ). This will enable the accumulation signals to utilize the input samples from the “future” steps of the unrolled LSTM cell without excessively increasing the number of parameters to be learned, since the input samples from the “past” steps will be already absorbed by the state signal, s → [ n ] , due to recurrence. After making these substitutions, Eqs.  (126) – (129) become: (183) a → c u [ n ] = W x c u [ n ] ∗ x → [ n ] + W s c u s → [ n − 1 ] + W v c u v → [ n − 1 ] + b → c u (184) a → c s [ n ] = W x c s [ n ] ∗ x → [ n ] + W s c s s → [ n − 1 ] + W v c s v → [ n − 1 ] + b → c s (185) a → c r [ n ] = W x c r [ n ] ∗ x → [ n ] + W s c r s → [ n ] + W v c r v → [ n − 1 ] + b → c r (186) a → d u [ n ] = W x d u [ n ] ∗ x → [ n ] + W v d u v → [ n − 1 ] + b → d u To examine the convolutional terms in more detail, let every context window filter, W x [ n ] (with the respective subscript), have L non-zero matrix-valued terms. For example, if L = 4 , then W x [ 0 ] , W x [ − 1 ] , W x [ − 2 ] , and W x [ − 3 ] will be non-zero. 30

By the definition of the discrete convolution , (187) W x [ n ] ∗ x → [ n ] = ∑ l = − L + 1 0 W x [ l ] x → [ n − l ] = ∑ l = 0 L − 1 W x [ − l ] x → [ n + l ] In the above example, the result on the left hand side of Eq.  (187) for each step with the index, n , will be influenced by the window spanning 4 input samples: x → [ 0 ] , x → [ 1 ] , x → [ 2 ] , and x → [ 3 ] .

If we redefine W x [ n ] to be non-zero for n ≥ 0 , then Eq.  (187) simplifies to: (188) W x [ n ] ∗ x → [ n ] = ∑ l = 0 L − 1 W x [ l ] x → [ n + l ] The dependence of the left hand side of Eq.  (188) on the input samples from the “future” steps of the unrolled LSTM cell is readily apparent from the expression for the convolution sum on the right hand side of Eq.  (188) .

By taking advantage of the available input samples within a small window surrounding each step of the sequence, the system can learn to “discern” the context in which the given step occurs. The inspiration for this “look-ahead” extension comes from the way people sometimes find it beneficial to read forward to the end of the sentence in order to better understand a phrase occurring in the earlier part of the sentence. It would be interesting to explore the relative trade-offs between the cost of adding a small number of parameter matrices to Θ so as to accommodate the input context windows with the computational burden of training a bi-directional LSTM network  [72] , and to compare the performance of the two architectures on several data sets. 31
7.2. Recurrent projection layer

Another modification of the Vanilla LSTM cell redefines the cell’s value signal to be the product of an additional matrix of weights 32 with the LSTM cell’s value signal from Eq.  (136) . To insert the recurrent projection layer into the Vanilla LSTM cell, we adjust Eq.  (136) as follows: (189) q → [ n ] = g → c r [ n ] ⊙ r → [ n ] (190) v → [ n ] = W q d r q → [ n ] where W q d r implements the recurrent projection layer, 33 and the intermediate cell quantity, q → [ n ] (which we will call the cell’s “qualifier” signal), replaces what used to be the cell’s value signal in the Vanilla LSTM cell. The new value signal of the cell from Eq.  (190) will now be used for computing the accumulation signals in Eqs.  (183) – (186) .

Let d v denote the dimensionality of the observable value signal of the cell; then v → ∈ R d v and W q d r ∈ R d v × d s . The degree to which the dimensionality reduction of the cell’s value signal can be tolerated for the given application directly contributes to speeding up the training phase of the system. By allowing d v < d s , the matrix multipliers of all the terms involving v → [ n − 1 ] , which dominate Eqs.  (183) – (186) (or Eqs.  (126) – (129) in the absence of the external input context windows), will contain correspondingly fewer columns. In contrast, in the Vanilla LSTM cell as covered in Section  6 (i.e., without the recurrent projection layer), d v must equal d s , since v → [ n ] is on the same data path as s → [ n ] , with no signal transformations along the data path between them. Hence, the addition of the recurrent projection layer to the Vanilla LSTM cell brings about the flexibility of trading off the representational capacity of the cell with the computational cost of learning its parameters [24] .
7.3. Controlling external input with a new gate

Section  5 argues that the two components of the data update accumulation node, a → d u [ n ] , in the Vanilla LSTM cell are not treated the same way from the standpoint of control. While the readout candidate signal is throttled by the control readout gate, g → c r [ n ] , the external input is always injected at the full 100 % contribution of its signal strength. This is not as much of an issue for the control accumulation nodes ( a → c u [ n ] , a → c s [ n ] , and a → c r [ n ] ), because they influence the scaling of the data signals, not the relative mixing of the data signals themselves. However, since the data update accumulation node, a → d u [ n ] , is directly in the path of the cell’s state signal, the ability to regulate both components of a → d u [ n ] can improve the cell’s capacity to adapt to the nuances and fluctuations in the training data. For instance, the control readout gate, g → c r [ n ] , can diminish the effect of the cell’s readout signal from the adjacent step in favor of making the external input signal at the given step more prominent in the make up of the cell’s state signal. Likewise, having the additional flexibility to fine-tune the external input component of a → d u [ n ] at the same granularity as its readout component (i.e., at the level of the individual step with the index, n ) would provide a means for training the LSTM cell to suppress interference due to noisy or spurious input samples.

As a mechanism for adjusting the contribution of the external input, Eq.  (106) introduced the control input gate, g → c x [ n ] , which we will apply to the convolution term in Eq.  (186) . Analogously to the other gates, g → c x [ n ] is computed by taking the warping function for control, given by Eq.  (121) , of the accumulation signal for controlling the input, element by element.

From Section  6.6 and Eq.  (186) , the data update accumulation node, a → d u [ n ] , is followed by the data warping function that produces the update candidate signal, u → [ n ] , of the cell at the present step with the index, n . The new control input gate, g → c x [ n ] , will throttle W x d u [ n ] ∗ x → [ n ] , the term representing the composite external input signal in Eq.  (186) for a → d u [ n ] . Letting ξ → x d u [ n ] ≡ W x d u [ n ] ∗ x → [ n ] , where ξ → x d u [ n ] denotes the composite external input signal for the data update accumulation node, a → d u [ n ] , this gating operation will be accomplished through the element-wise multiplication, g → c x [ n ] ⊙ ξ → x d u [ n ] , the method used by all the other gates to control the fractional amount of their designated data signals.

The equations for accommodating the new control input gate, g → c x [ n ] , as part of the LSTM cell design as well as the equation for the data update accumulation node, a → d u [ n ] , modified to take advantage of this new gate, are provided below: (191) ξ → x c x [ n ] = W x c x [ n ] ∗ x → [ n ] (192) a → c x [ n ] = ξ → x c x [ n ] + W s c x s → [ n − 1 ] + W v c x v → [ n − 1 ] + b → c x (193) g → c x [ n ] = G c ( a → c x [ n ] ) (194) ξ → x d u [ n ] = W x d u [ n ] ∗ x → [ n ] (195) a → d u [ n ] = g → c x [ n ] ⊙ ξ → x d u [ n ] + W v d u v → [ n − 1 ] + b → d u where the additional parameters, needed to characterize the accumulation node, a → c x [ n ] , of the new control input gate, g → c x [ n ] , have the following interpretation:

    •

    W x c x [ l ] ∈ R d x × d x — the matrices of weights (for 0 ≤ l ≤ L − 1 ) connecting the input signal, x → [ n + l ] , at the step with the index, n + l , to the “control input” accumulation node, a → c x [ n ] , of the cell at the present step with the index, n
    •

    W s c x ∈ R d x × d s — the matrix of weights connecting the state signal, s → [ n − 1 ] , at the adjacent lower-indexed step with the index, n − 1 , to the “control input” accumulation node, a → c x [ n ] , of the cell at the present step with the index, n
    •

    W v c x ∈ R d x × d v — the matrix of weights connecting the externally-accessible (observable) value signal, v → [ n − 1 ] , at the adjacent lower-indexed step with the index, n − 1 , to the “control input” accumulation node, a → c x [ n ] , of the cell at the present step with the index, n
    •

    b → c x ∈ R d x — the vector of bias elements for the “control input” accumulation node, a → c x [ n ] , of the cell at the present step with the index, n
    •

    W x d u [ l ] ∈ R d s × d x — the matrices of weights (for 0 ≤ l ≤ L − 1 ) connecting the input signal, x → [ n + l ] , at the step with the index, n + l , to the “data update” accumulation node, a → d u [ n ] , of the cell at the present step with the index, n

7.4. Augmented LSTM system equations (“forward pass”)

We are now ready to assemble the equations for the Augmented LSTM system by enhancing the Vanilla LSTM network with the new functionality, presented earlier in this section — the recurrent projection layer, the non-causal input context windows, and the input gate: (196) ξ → x c u [ n ] = W x c u [ n ] ∗ x → [ n ] (197) a → c u [ n ] = ξ → x c u [ n ] + W s c u s → [ n − 1 ] + W v c u v → [ n − 1 ] + b → c u (198) g → c u [ n ] = G c ( a → c u [ n ] ) (199) ξ → x c s [ n ] = W x c s [ n ] ∗ x → [ n ] (200) a → c s [ n ] = ξ → x c s [ n ] + W s c s s → [ n − 1 ] + W v c s v → [ n − 1 ] + b → c s (201) g → c s [ n ] = G c ( a → c s [ n ] ) (202) ξ → x c r [ n ] = W x c r [ n ] ∗ x → [ n ] (203) a → c r [ n ] = ξ → x c r [ n ] + W s c r s → [ n ] + W v c r v → [ n − 1 ] + b → c r (204) g → c r [ n ] = G c ( a → c r [ n ] ) (205) ξ → x c x [ n ] = W x c x [ n ] ∗ x → [ n ] (206) a → c x [ n ] = ξ → x c x [ n ] + W s c x s → [ n − 1 ] + W v c x v → [ n − 1 ] + b → c x (207) g → c x [ n ] = G c ( a → c x [ n ] ) (208) ξ → x d u [ n ] = W x d u [ n ] ∗ x → [ n ] (209) a → d u [ n ] = g → c x [ n ] ⊙ ξ → x d u [ n ] + W v d u v → [ n − 1 ] + b → d u (210) u → [ n ] = G d ( a → d u [ n ] ) (211) s → [ n ] = g → c s [ n ] ⊙ s → [ n − 1 ] + g → c u [ n ] ⊙ u → [ n ] (212) r → [ n ] = G d ( s → [ n ] ) (213) q → [ n ] = g → c r [ n ] ⊙ r → [ n ] (214) v → [ n ] = W q d r q → [ n ] with the dimensions of the parameters adjusted to take into account the recurrent projection layer:

W x c u [ l ] ∈ R d s × d x , W s c u ∈ R d s × d s , W v c u ∈ R d s × d v , b → c u ∈ R d s ,

W x c s [ l ] ∈ R d s × d x , W s c s ∈ R d s × d s , W v c s ∈ R d s × d v , b → c s ∈ R d s ,

W x c r [ l ] ∈ R d s × d x , W s c r ∈ R d s × d s , W v c r ∈ R d s × d v , b → c r ∈ R d s ,

W x c x [ l ] ∈ R d x × d x , W s c x ∈ R d x × d s , W v c x ∈ R d x × d v , b → c x ∈ R d x ,

W x d u [ l ] ∈ R d s × d x , W v d u ∈ R d s × d v , b → d u ∈ R d s , and W q d r ∈ R d v × d s , where 0 ≤ l ≤ L − 1 and d v ≤ d s .

The schematic diagram of the Augmented LSTM cell appears in Fig. 10 .

Combining all the matrix and vector parameters of the Augmented LSTM cell, described by Eqs.  (196) – (214) , into: (215) Θ ≡ completes the definition of the inference phase (forward pass) of the Augmented LSTM cell.

    Download : Download high-res image (617KB)
    Download : Download full-size image 

Fig. 10 . Augmented LSTM network cell system schematics.
7.5. Augmented LSTM system derivatives: Backward pass

The equations for training the Augmented LSTM cell, unrolled for K steps, using BPTT, are obtained by adopting the same method as was used for the Vanilla LSTM cell in Section  6.9 . We rely on the same border and intermediate total partial derivatives, appearing in Eqs.  (139) – (143) , with the addition of the total partial derivative of the objective function, E , with respect to the qualifier signal, q → [ n ] : (216) β → [ n ] ≡ ∇ → q → [ n ] E = ∂ E ∂ q → [ n ] which is an intermediate total partial derivative that reflects the insertion of the projection layer into the cell’s data path. Applying the chain rule to the Augmented LSTM cell, defined by Eqs.  (196) – (214) , and judiciously utilizing all of these border and intermediate total partial derivatives, yields the backward pass equations for the Augmented LSTM cell: (217) χ → [ n ] = ∂ y → [ n ] ∂ v → [ n ] T ∂ E ∂ y → [ n ] + f χ → [ n + 1 ] (218) β → [ n ] = ∂ v → [ n ] ∂ q → [ n ] T ∂ E ∂ v → [ n ] = W q d r T χ → [ n ] (219) ρ → [ n ] = ∂ q → [ n ] ∂ r → [ n ] T ∂ E ∂ q → [ n ] = ( ∇ → q → [ n ] E ) ⊙ g → c r [ n ] = β → [ n ] ⊙ g → c r [ n ] = W q d r T χ → [ n ] ⊙ g → c r [ n ] (220) γ → c r [ n ] = ∂ E ∂ q → [ n ] ∂ q → [ n ] ∂ g → c r [ n ] = ( ∇ → q → [ n ] E ) ⊙ r → [ n ] = β → [ n ] ⊙ r → [ n ] = W q d r T χ → [ n ] ⊙ r → [ n ] (221) α → c r [ n ] = γ → c r [ n ] ⊙ ∂ g → c r [ n ] ∂ a → c r [ n ] = γ → c r [ n ] ⊙ d G c ( z ) d z ⌋ z = a → c r [ n ] = W q d r T χ → [ n ] ⊙ r → [ n ] ⊙ d G c ( z ) d z ⌋ z = a → c r [ n ] (222) ψ → [ n ] = ρ → [ n ] ⊙ ∂ r → [ n ] ∂ s → [ n ] + ∂ a → c r [ n ] ∂ s → [ n ] α → c r [ n ] + f ψ → [ n + 1 ] = ρ → [ n ] ⊙ d G d ( z → ) d z → ⌋ z = s → [ n ] + W s c r α → c r [ n ] + f ψ → [ n + 1 ] = W q d r T χ → [ n ] ⊙ g → c r [ n ] ⊙ d G d ( z → ) d z → ⌋ z = s → [ n ] + W s c r α → c r [ n ] + f ψ → [ n + 1 ] (223) α → c s [ n ] = ψ → [ n ] ⊙ ∂ s → [ n ] ∂ g → c s [ n ] ⊙ ∂ g → c s [ n ] ∂ a → c s [ n ] = ψ → [ n ] ⊙ s → [ n − 1 ] ⊙ d G c ( z → ) d z → ⌋ z = a → c s [ n ] (224) α → c u [ n ] = ψ → [ n ] ⊙ ∂ s → [ n ] ∂ g → c u [ n ] ⊙ ∂ g → c u [ n ] ∂ a → c u [ n ] = ψ → [ n ] ⊙ u → [ n ] ⊙ d G c ( z → ) d z → ⌋ z = a → c u [ n ] (225) α → d u [ n ] = ψ → [ n ] ⊙ ∂ s → [ n ] ∂ u → [ n ] ⊙ d G d ( z → ) d z → ⌋ z = a → d u [ n ] = ψ → [ n ] ⊙ g → c u [ n ] ⊙ d G d ( z → ) d z → ⌋ z = a → d u [ n ] (226) γ → c x [ n ] = α → d u [ n ] ∂ u → [ n ] ∂ g → c x [ n ] = α → d u [ n ] ⊙ ξ → x d u [ n ] (227) α → c x [ n ] = γ → c x [ n ] ⊙ ∂ g → c x [ n ] ∂ a → c x [ n ] = γ → c x [ n ] ⊙ d G c ( z ) d z ⌋ z = a → c x [ n ] = α → d u [ n ] ⊙ ξ → x d u [ n ] ⊙ d G c ( z ) d z ⌋ z = a → c r [ n ] = ψ → [ n ] ⊙ g → c u [ n ] ⊙ ξ → x d u [ n ] ⊙ d G d ( z → ) d z → ⌋ z = a → d u [ n ] ⊙ d G c ( z ) d z ⌋ z = a → c r [ n ] where: (228) f χ → [ n + 1 ] = W v c u α → c u [ n + 1 ] + W v c s α → c s [ n + 1 ] + W v c r α → c r [ n + 1 ] + W v c x α → c x [ n + 1 ] + W v d u α → d u [ n + 1 ] (229) f ψ → [ n + 1 ] = W s c u α → c u [ n + 1 ] + W s c s α → c s [ n + 1 ] + W s c x α → c x [ n + 1 ] + g → c s [ n + 1 ] ⊙ ψ → [ n + 1 ] Referring once again to the definition of the Augmented LSTM cell in Eqs.  (196) – (214) , we obtain: (230) ∂ E ∂ W x c u [ l ] [ n ] = α → c u [ n ] x → T [ n + l ] (231) ∂ E ∂ W s c u [ n ] = α → c u [ n ] s → T [ n − 1 ] (232) ∂ E ∂ W v c u [ n ] = α → c u [ n ] v → T [ n − 1 ] (233) ∂ E ∂ b → c u [ n ] = α → c u [ n ] (234) ∂ E ∂ W x c s [ l ] [ n ] = α → c s [ n ] x → T [ n + l ] (235) ∂ E ∂ W s c s [ n ] = α → c s [ n ] s → T [ n − 1 ] (236) ∂ E ∂ W v c s [ n ] = α → c s [ n ] v → T [ n − 1 ] (237) ∂ E ∂ b → c s [ n ] = α → c s [ n ] (238) ∂ E ∂ W x c r [ l ] [ n ] = α → c r [ n ] x → T [ n + l ] (239) ∂ E ∂ W s c r [ n ] = α → c r [ n ] s → T [ n ] (240) ∂ E ∂ W v c r [ n ] = α → c r [ n ] v → T [ n − 1 ] (241) ∂ E ∂ b → c r [ n ] = α → c r [ n ] (242) ∂ E ∂ W x c x [ l ] [ n ] = α → c x [ n ] x → T [ n + l ] (243) ∂ E ∂ W s c x [ n ] = α → c x [ n ] s → T [ n − 1 ] (244) ∂ E ∂ W v c x [ n ] = α → c x [ n ] v → T [ n − 1 ] (245) ∂ E ∂ b → c x [ n ] = α → c x [ n ] (246) ∂ E ∂ W x d u [ l ] [ n ] = α → d u [ n ] x → T [ n + l ] (247) ∂ E ∂ W v d u [ n ] = α → d u [ n ] v → T [ n − 1 ] (248) ∂ E ∂ b → d u [ n ] = α → d u [ n ] (249) ∂ E ∂ W q d r [ n ] = χ → [ n ] v → T [ n ] where 0 ≤ l ≤ L − 1 and 0 ≤ n ≤ K − 1 . Arranged to parallel the structure of Θ , defined in Eq.  (215) , the total partial derivative of the objective function, E , with respect to the model parameters, Θ , at the step with the index, n , is: (250) ∂ E ∂ Θ [ n ] = Finally, d E d Θ , the total derivative of the objective function, E , with respect to the model parameters, Θ , for the entire unrolled sequence is computed by Eq.  (172) . Aggregated over a batch of segments, d E d Θ is plugged in to the Gradient Descent training algorithm for learning the model parameters, Θ .
8. Conclusions and future work

In this paper, we presented the fundamentals of the RNN and the LSTM network using a principled approach. Starting with the differential equations encountered in many branches of science and engineering, we showed that the canonical formulation of the RNN can be obtained by sampling delay differential equations used to model processes in physics , life sciences, and neural networks. We proceeded to obtain the standard RNN formulation by appropriately choosing the parameters of the canonical RNN equations and applying stability considerations. We then formally explained RNN unrolling within the framework of approximating an IIR system by an FIR model and proved the sufficient conditions for its applicability to learning sequences. Next, we presented the training of the standard RNN using Back Propagation Through Time, segueing to the review of the vanishing and exploding gradients, the well-known numerical difficulties, associated with training the standard RNN by Gradient Descent. We subsequently addressed the shortcomings of the standard RNN by morphing the canonical RNN system into the more robust LSTM network through a series of extensions and embellishments. In addition to the logical construction of the Vanilla LSTM network from the canonical RNN, we included a self-contained overview of the Vanilla LSTM network, complete with the specifications of all principal entities as well as clear, descriptive, yet concise, presentations of the forward pass and, importantly, the backward pass, without skipping any steps. The main contribution up to this point has been our unique pedagogical approach for analyzing the RNN and Vanilla LSTM systems from the Signal Processing perspective, a formal derivation of the RNN unrolling procedure, and a thorough treatment using a descriptive and meaningful notation, aimed at demystifying the underlying concepts. Moreover, as an unexpected benefit of our analysis, we identified two novel extensions to the Vanilla LSTM network: the convolutional non-causal input context windows and the external input gate. We then augmented the equations for the LSTM cell with these extensions (along with the recurrent projection layer, previously introduced by another researcher team). Candidate recommendations for future work include implementing the Augmented LSTM system within a high-performance computing environment and benchmarking its efficacy in multiple practical scenarios. The use of the Augmented LSTM could potentially benefit the language representation subsystems used in question answering and in automating customer support. For these applications, it will be important to evaluate the performance impact, attributed to the non-causal input context windows, as compared to the different baselines, such the Vanilla LSTM network, the bi-directional LSTM network, the Transformer, and other state-of-the-art models. Also of particular relevance to this use case will be to measure the effectiveness of the external input gate in helping to eliminate the non-essential content from the input sequences. Finally, adopting the Augmented LSTM network to other practical domains and publishing the results is respectfully encouraged.
CRediT authorship contribution statement

Alex Sherstinsky: Conceptualization, Methodology, Formal analysis, Investigation, Resources, Writing - original draft, Writing - review & editing.
Acknowledgments

The author thanks Eugene Mandel for long-time collaboration and engaging discussions, which were instrumental in clarifying the key concepts, as well as for his encouragement and support. Tremendous gratitude is expressed to Tom Minka for providing helpful critique and valuable comments and to Mike Singer for reviewing the proposition and correcting errors in the proof. Big thanks go to Varuna Jayasiri, Eduardo G. Ponferrada, Flavia Sparacino, and Janet Cahn for proofreading the manuscript.
References

    [1]
    Hochreiter Sepp, Schmidhuber Jürgen
    Long short-term memory
    Neural Comput., 9 (8) (1997), pp. 1735-1780
    CrossRef View in Scopus Google Scholar
    [2]
    Lin Henry W., Tegmark Max
    Criticality in formal languages and statistical physics
    Entropy, 19 (7) (2017), p. 299
    CrossRef View in Scopus Google Scholar
    [3]
    Sanger Terence D.
    Optimal unsupervised learning in a single-layer linear feedforward neural network
    Neural Netw., 2 (1989), pp. 459-473
    View PDF View article View in Scopus Google Scholar
    [4]
    Sherstinsky Alex
    M-Lattice: A System for Signal Synthesis and Processing Based on Reaction-Diffusion
    (Ph.D. thesis)
    Massachusetts Institute of Technology (1994)
    Google Scholar
    [5]
    Liao Qianli, Tomaso A. Poggio Max
    Bridging the gaps between residual learning, recurrent neural networks and visual cortex
    CoRR, abs/1604.03640 (2016)
    Google Scholar
    [6]
    Haber Eldad, Ruthotto Lars
    Stable architectures for deep neural networks
    Inverse Problems, 34 (1) (2017), Article 014004
    Google Scholar
    [7]
    Lu Yiping, Zhong Aoxiao, Li Quanzheng, Dong Bin
    Beyond finite layer neural networks: Bridging deep architectures and numerical differential equations
    Dy Jennifer G., Krause Andreas (Eds.), ICML, Proceedings of Machine Learning Research, vol. 80, PMLR (2018), pp. 3282-3291
    Google Scholar
    [8]
    Ruthotto Lars, Haber Eldad
    Deep neural networks motivated by partial differential equations
    CoRR, abs/1804.04272, (2018)
    Google Scholar
    [9]
    Sherstinsky Alex
    Fundamentals of recurrent neural network (RNN) and long short-term memory (LSTM) network
    (2018)
    arxiv:1808.03314 , 39 pages, 10 figures, 66 references.
    Google Scholar
    [10]
    Sherstinsky Alex
    Deriving the recurrent neural network definition and rnn unrolling using signal processing
    Critiquing and Correcting Trends in Machine Learning Workshop at Neural Information Processing Systems, vol. 31, NeurIPS 2018 (2018)
    Organizers: Benjamin Bloem-Reddy, Brooks Paige, Matt J. Kusner, Rich Caruana, Tom Rainforth, and Yee Whye Teh
    Google Scholar
    [11]
    Ciccone Marco, Gallieri Marco, Masci Jonathan, Osendorfer Christian, Gomez Faustino J.
    Nais-net: Stable deep networks from non-autonomous differential equations
    Bengio Samy, Wallach Hanna M., Larochelle Hugo, Grauman Kristen, Cesa-Bianchi Nicoló, Garnett Roman (Eds.), NeurIPS (2018), pp. 3029-3039
    Google Scholar
    [12]
    Chang Bo, Meng Lili, Haber Eldad, Ruthotto Lars, Begert David, Holtham Elliot
    Reversible architectures for arbitrarily deep residual neural networks
    McIlraith Sheila A., Weinberger Kilian Q. (Eds.), AAAI, AAAI Press (2018), pp. 2811-2818
    View in Scopus Google Scholar
    [13]
    Bo Chang, Minmin Chen, Eldad Haber, Ed H. Chi, AntisymmetricRNN: A dynamical system view on recurrent neural networks. in: International Conference on Learning Representations, 2019.
    Google Scholar
    [14]
    Chen Tian Qi, Rubanova Yulia, Bettencourt Jesse, Duvenaud David
    Neural ordinary differential equations
    Bengio Samy, Wallach Hanna M., Larochelle Hugo, Grauman Kristen, Cesa-Bianchi Nicoló, Garnett Roman (Eds.), NeurIPS (2018), pp. 6572-6583
    Google Scholar
    [15]
    Rubanova Yulia, Ricky T.Q. Chen, Duvenaud David
    Latent odes for irregularly-sampled time series
    (2019)
    arxiv:1907.03907
    Google Scholar
    [16]
    Greff Klaus, Srivastava Rupesh Kumar, Koutník Jan, Steunebrink Bas R., Schmidhuber Jürgen
    LSTM: A search space Odyssey
    CoRR, abs/1503.04069 (2015)
    Google Scholar
    [17]
    Graves A., Schmidhuber J.
    Framewise phoneme classification with bidirectional LSTM and other neural network architectures
    Neural Netw., 18 (5–6) (2005), pp. 602-610
    View PDF View article View in Scopus Google Scholar
    [18]
    A. Graves, J. Schmidhuber, Framewise phoneme classification with bidirectional LSTM networks. in: Proc. Int. Joint Conf. on Neural Networks IJCNN 2005, 2005.
    Google Scholar
    [19]
    Graves Alex
    Supervised Sequence Labelling with Recurrent Neural Networks
    (Ph.D. thesis)
    Technical University Munich (2008)
    Google Scholar
    [20]
    Sutskever Ilya, Martens James, Hinton Geoffrey E.
    Generating text with recurrent neural networks
    Getoor Lise, Scheffer Tobias (Eds.), ICML, Omnipress (2011), pp. 1017-1024
    View in Scopus Google Scholar
    [21]
    Martin Sundermeyer, Ralf Schlüter, Hermann Ney, LSTM neural networks for language modeling. in: Interspeech, 2012, 194–197.
    Google Scholar
    [22]
    Graves Alex
    Generating sequences with recurrent neural networks
    CoRR, abs/1308.0850 (2013)
    Google Scholar
    [23]
    Sutskever Ilya, Vinyals Oriol, Le Quoc V.
    Sequence to sequence learning with neural networks
    Advances in Neural Information Processing Systems (2014), pp. 3104-3112
    View in Scopus Google Scholar
    [24]
    Sak Hasim, Senior Andrew W., Beaufays Françoise
    Long short-term memory recurrent neural network architectures for large scale acoustic modeling
    Li Haizhou, Meng Helen M., Ma Bin, Chng Engsiong, Xie Lei (Eds.), Interspeech, ISCA (2014), pp. 338-342
    CrossRef View in Scopus Google Scholar
    [25]
    Lipton Zachary Chase
    A critical review of recurrent neural networks for sequence learning
    CoRR, abs/1506.00019 (2015)
    Google Scholar
    [26]
    Karpathy Andrej
    The unreasonable effectiveness of recurrent neural networks
    (2015)
    http://karpathy.github.io/2015/05/21/rnn-effectiveness
    Google Scholar
    [27]
    Olah Christopher
    Understanding LSTM networks
    (2015)
    http://colah.github.io/posts/2015-08-Understanding-LSTMs
    Google Scholar
    [28]
    Palangi Hamid, Deng Li, Shen Yelong, Gao Jianfeng, He Xiaodong, Chen Jianshu, Song Xinying, Ward Rabab K.
    Deep sentence embedding using the long short term memory network: Analysis and application to information retrieval
    CoRR, abs/1502.06922 (2015)
    Google Scholar
    [29]
    Kannan Anjuli, Kurach Karol, Ravi Sujith, Kaufmann Tobias, Tomkins Andrew, Miklos Balint, Corrado Greg, Lukács László, Ganea Marina, Young Peter, Ramavajjala Vivek
    Smart reply: Automated response suggestion for email
    CoRR, abs/1606.04870 (2016)
    Google Scholar
    [30]
    Zhou Jie, Cao Ying, Wang Xuguang, Li Peng, Xu Wei
    Deep recurrent models with fast-forward connections for neural machine translation
    CoRR, abs/1606.04199 (2016)
    Google Scholar
    [31]
    Renvoisé Paul
    Machine learning spotlight i: Investigating recurrent neural networks
    (2017)
    https://recast.ai/blog/ml-spotlight-rnn/
    Google Scholar
    [32]
    Chen Edwin
    Exploring LSTMs
    (2017)
    http://blog.echen.me/2017/05/30/exploring-lstms
    Google Scholar
    [33]
    Mallya Arun
    LSTM forward and backward pass
    (2017)
    http://arunmallya.github.io/writeups/nn/lstm/index.html
    Google Scholar
    [34]
    Mallya Arun
    Introduction to RNNs
    (2017)
    http://slazebni.cs.illinois.edu/spring17/lec02_rnn.pdf
    Google Scholar
    [35]
    Mallya Arun
    Some RNN variants
    (2017)
    http://slazebni.cs.illinois.edu/spring17/lec03_rnn.pdf
    Google Scholar
    [36]
    Jayasiri Varuna
    Vanilla LSTM with numpy
    (2017)
    http://blog.varunajayasiri.com/numpy_lstm.html
    Google Scholar
    [37]
    Salehinejad Hojjat, Baarbe Julianne, Sankar Sharan, Barfett Joseph, Colak Errol, Valaee Shahrokh
    Recent advances in recurrent neural networks
    CoRR, abs/1801.01078 (2018)
    Google Scholar
    [38]
    Strogatz S.H.
    Nonlinear Dynamics and Chaos
    Westview Press, Cambridge, MA (1994)
    Google Scholar
    [39]
    Wang Yu
    A new concept using LSTM neural networks for dynamic system identification
    ACC, IEEE (2017), pp. 5324-5329
    View in Scopus Google Scholar
    [40]
    Grossberg S.
    Recurrent neural networks
    Scholarpedia, 8 (2) (2013), p. 1888
    revision #138057
    CrossRef Google Scholar
    [41]
    Hopfield J.J.
    Neurons with graded response have collective computational properties like those of two-state neurons
    Proc. Natl. Acad. Sci., 81 (1984), pp. 3088-3092
    CrossRef View in Scopus Google Scholar
    [42]
    Grossberg Stephen
    Nonlinear neural networks: Principles, mechanisms, and architectures
    Neural Netw., 1 (1988), pp. 17-61
    View PDF View article View in Scopus Google Scholar
    [43]
    Sherstinsky Alex, Picard Rosalind W.
    M-lattice: from morphogenesis to image processing
    IEEE Trans. Image Process., 5 (7) (1996), pp. 1137-1149
    Google Scholar
    [44]
    Yuliya Kyrychko, Stephen Hogan, On the use of delay equations in engineering applications, 16 (2010) 943–960.
    Google Scholar
    [45]
    Metropolis N., Rosenbluth A., Rosenbluth M., Teller A., Teller E.
    Equation of state calculations by fast computing machines
    J. Chem. Phys., 21 (1953), p. 1087
    CrossRef View in Scopus Google Scholar
    [46]
    Sherstinsky Alex, Picard Rosalind W.
    On stability and equilibria of the M-Lattice
    IEEE Trans. Circuit Syst. I, 45 (4) (1998), pp. 408-415
    View in Scopus Google Scholar
    [47]
    Ostroverkhyi Oleksii
    Neural Network Processing of Multidimensional Signals
    (Ph.D. thesis)
    Kharkiv National University of Radioelectronics (2010)
    Google Scholar
    [48]
    Jordan M.I.
    Serial Order: A Parallel Distributed Processing Approach: Technical Report ICS Report 8604
    Institute for Cognitive Science, University of California, San Diego (1986)
    Google Scholar
    [49]
    Pineda F.J.
    Generalization of backpropagation to recurrent neural networks
    Phys. Rev. Lett., 59 (19) (1987), pp. 2229-2232
    View in Scopus Google Scholar
    [50]
    Fernando L. Pineda F.J.
    Generalization of backpropagation to recurrent and higher order neural networks
    Anderson Dana Z. (Ed.), Neural Information Processing Systems, American Institute of Physics, New York (1987), pp. 602-611
    Google Scholar
    [51]
    Pearlmutter Barak A.
    Learning state space trajectories in recurrent neural networks
    Neural Comput., 1 (2) (1989), pp. 263-269
    CrossRef Google Scholar
    [52]
    Elman J.L.
    Finding structure in time
    Cogn. Sci., 14 (1990), pp. 179-211
    View PDF View article View in Scopus Google Scholar
    [53]
    Barak A. Pearlmutter J.L.
    Dynamic Recurrent Neural Networks
    Computer Science Department, Carnegie Mellon University, Pittsburgh, PA (1990)
    Google Scholar
    [54]
    de Vries B., Principe J.C.
    A theory for neural networks with time delays
    Lippmann R.P., Moody J.E., Touretzky D.S. (Eds.), Advances in Neural Information Processing Systems 3, Morgan Kaufmann (1991), pp. 162-168
    Google Scholar
    [55]
    Chua Leon O., Yang Lin
    Cellular neural networks: Theory
    IEEE Trans. Circuits Syst., 35 (1988), pp. 1257-1272
    View in Scopus Google Scholar
    [56]
    Chua Leon O., Yang Lin
    Cellular neural networks: Applications
    IEEE Trans. Circuits Syst., 35 (1988), pp. 1273-1290
    View in Scopus Google Scholar
    [57]
    Lloyd N. Trefethen, Finite Difference and Spectral Methods for Ordinary and Partial Differential Equations. unpublished text, Cambridge, MA, 1996.
    Google Scholar
    [58]
    Oppenheim A.V., Schafer R.W.
    Discrete-Time Signal Processing
    Prentice-Hall (1989)
    Google Scholar
    [59]
    Vinyals Oriol
    Beyond Deep Learning: Scalable Methods and Models for Learning
    (Ph.D. thesis)
    EECS Department, University of California, Berkeley (2013)
    Google Scholar
    [60]
    Sherstinsky Alex, Picard Rosalind W.
    On the efficiency of the orthogonal least squares training method for radial basis function networks
    IEEE Trans. Neural Netw., 7 (1) (1996), pp. 195-200
    View in Scopus Google Scholar
    [61]
    Bose Amar Gopal
    A Theory of Nonlinear Systems
    (Ph.D. thesis)
    Massachusetts Institute of Technology (1956)
    Google Scholar
    [62]
    Hochreiter Sepp, Yoshua Bengio, Paolo Frasconi, Schmidhuber Jürgen
    Gradient flow in recurrent nets: the difficulty of learning long-term dependencies
    Kremer R.P., Kolen J.E. (Eds.), A Field Guide to Dynamical Recurrent Neural Networks, IEEE Press (2001)
    Google Scholar
    [63]
    Razvan Pascanu, Tomas Mikolov, Yoshua Bengio, On the difficulty of training recurrent neural networks. in: International Conference on Machine Learning, 2013, pp. 1310–1318.
    Google Scholar
    [64]
    Werbos P.J.
    Generalization of backpropagation with application to a recurrent gas market model
    Neural Netw., 1 (1988)
    Google Scholar
    [65]
    Werbos P.
    Backpropagation through time: what does it do and how to do it
    Proceedings of IEEE, vol. 78 (1990), pp. 1550-1560
    View in Scopus Google Scholar
    [66]
    Sutskever Ilya
    Training Recurrent Neural Networks
    (Ph.D. thesis)
    University of Toronto (2012)
    Google Scholar
    [67]
    Pascanu Razvan
    On Recurrent and Deep Neural Networks
    (Ph.D. thesis)
    Université de Montréal (2014)
    Google Scholar
    [68]
    Rumelhart D.E., Hinton G.E., Williams R.J.
    Learning Internal Representations By Error Propagation: Technical Report DTIC Document
    University of California, San Diego (1985)
    Google Scholar
    [69]
    Parallel Distributed Processing, volume 1
    MIT Press (1986)
    Google Scholar
    [70]
    Minsky M.L., Papert S.A.
    Perceptrons
    (second ed.), MIT Press, Cambridge MA (1990)
    Google Scholar
    [71]
    Williams Ronald J., Zipser David
    A learning algorithm for continually running fully recurrent neural networks
    Neural Comput., 1 (1989), pp. 270-280
    CrossRef Google Scholar
    [72]
    Schuster Mike, Paliwal Kuldip K.
    Bidirectional recurrent neural networks
    IEEE Trans. Signal Process., 45 (1997), pp. 2673-2681
    View in Scopus Google Scholar
    [73]
    Levy Omer, Lee Kenton, FitzGerald Nicholas, Zettlemoyer Luke
    Long short-term memory as a dynamically computed element-wise weighted sum
    CoRR, abs/1805.03716 (2018)
    Google Scholar
    [74]
    Gers Felix
    Long Short-Term Memory in Recurrent Neural Networks
    (Ph.D. thesis)
    École Polytechnique Fédérale de Lausanne (2001)
    Google Scholar
    [75]
    Rabiner L.R.
    Techniques for designing finite-duration impulse-response digital filters
    IEEE Trans. Commun. Technol., 19 (2) (1971), pp. 188-195
    View in Scopus Google Scholar
    [76]
    McClellan J.H., Parks T.W., Rabiner L.R.
    A computer program for designing optimum FIR linear phase digital filters
    IEEE Trans. Audio Electroacoust., 21 (6) (1973), pp. 506-526
    View in Scopus Google Scholar
    [77]
    Yamamoto Y., Anderson B.D.O., Nagahara M., Koyanagi Y.
    Optimizing FIR approximation for discrete-time IIR filters
    IEEE Signal Process. Lett., 10 (9) (2003), pp. 273-276
    View in Scopus Google Scholar
    [78]
    Zaremba Wojciech, Sutskever Ilya, Vinyals Oriol
    Recurrent neural network regularization
    (2014)
    arxiv:1409.2329
    Google Scholar

Cited by (2389)

    Fusing LSTM neural network and expanded disturbance Kalman filter for estimating external disturbing forces of ball screw drives
    2024, Robotics and Computer-Integrated Manufacturing
    Show abstract
    Continuous knee joint angle prediction with surface EMG
    2024, Biomedical Signal Processing and Control
    Show abstract
    Short-term PV power data prediction based on improved FCM with WTEEMD and adaptive weather weights
    2024, Journal of Building Engineering
    Show abstract
    FBN-TCN: Temporal convolutional neural network based on spatial domain fusion brain networks for affective brain–computer interfaces
    2024, Biomedical Signal Processing and Control
    Show abstract
    Prediction and risk analysis of Cardio Vascular diseases in IoHT by enhanced CHIO-based Residual and dilated gated network with Attention Mechanism
    2024, Biomedical Signal Processing and Control
    Show abstract
    TISE-LSTM: A LSTM model for precipitation nowcasting with temporal interactions and spatial extract blocks
    2024, Neurocomputing
    Show abstract

View all citing articles on Scopus

1

    The nickname “Vanilla LSTM” symbolizes this model’s flexibility and generality (Greff et al., 2015).

2

    An article co-authored by one of the LSTM inventors provides a self-contained summary of the embodiment of an RNN, though not at an introductory level  [16] .

3

    The entire input signal, c → ( t ) , in Eq.  (8) is sometimes referred to as the “external driving force” (or, simply, the “driving force”) in physics.

4

    In neural networks, time delay occurs in the interaction between neurons; it is induced by the finite switching speed of the neuron and the communication time between neurons  [44] , [47] .

5

    This term from neuroanatomy provides a biological motivation for considering networks containing multiple “hidden” layers, essentially what is dubbed “deep networks” and “deep learning” today.

6

    For example, the 2 -dimensional shape of i → is appropriate for image processing tasks.

7

    As mentioned earlier, a more appropriate phrase would be “neurally inspired” networks.

8

    The backward Euler method is a stable discretization rule used for solving ordinary differential equations numerically  [57] . A simple way to express this rule is to substitute the forward finite difference formula into the definition of the derivative, relax the requirement △ T → 0 , and evaluate the function on the right hand side (i.e., the quantity that the derivative is equal to) at time, t + △ T .

9

    It is straightforward to extend the application of the discretization rule to the full Eq.  (11) , containing any or all the time delay terms and their corresponding matrix coefficients, without the above simplifications. So there is no loss of generality.

10

    Again, the additional terms, containing similarly combined time delayed input signals (as will be shown to be beneficial later in this paper) and state signals, can be included in the discretization, relaxing the above simplifications as needed to suit the requirements of the particular problem at hand.

11

    The terms “unrolling” and “unfolding” are used interchangeably in association with RNN systems.

12

    The name “Back Propagation Through Time” reflects the origins of recurrent neural networks in continuous-time domain and differential equations. While not strictly accurate, given the discrete nature of the RNN system under consideration, “Back Propagation Through Time” is easy to remember, carries historical significance, and should not be the source of confusion.

13

    By convention, the element-wise multiplication by a vector is equivalent to the multiplication by a diagonal matrix, in which the elements of the vector occupy the main diagonal.

14

    A detailed treatment of the difficulties encountered in training RNNs is presented in  [63] . The problem is defined using Eq.  (80) , which leads to the formulas for the gradients of the individual objective function at each separate step with respect to the model’s parameters. Then the behavior of these formulas as a function of the index of the step is analyzed, following the approach in  [71] . In contrast, the present analysis follows the method described in [62] and  [18] , [19] , [64] , [65] . The total gradient of the objective function with respect to the state signal at each step is pre-computed using Eq.  (84) . Then the behavior of the members of this sequence as a function of the number of steps separating them is analyzed. The results and conclusions of these dual approaches are, of course, identical.

15

    In the remainder of this document, the prototype segment notation of Eq.  (74) is being omitted for simplicity. Unless otherwise specified, it is assumed that all operations are intended to be on the domain of a segment, where the sample index, n , traverses the steps of the segment, 0 ≤ n ≤ K m − 1 , for every segment with the index, m , in 0 ≤ m ≤ M − 1 .

16

    Throughout this document, the subscript “c” stands for “control”, while the subscript “d” stands for “data”.

17

    In discrete systems, the concept of time is only of historical significance. The proper terminology would be to use the word “adjacent” when referring to quantities at the neighboring steps. Here, the terms “previous”, “current”, and “next” are sometimes used only for convenience purposes. The RNN systems can be readily unrolled in the opposite direction, in which case all indices are negated and the meaning of “previous” and “next” is reversed. As a matter of fact, improved performance has been attained with bi-directional processing in a variety of applications  [16] , [19] , [24] , [25] , [30] , [72] . Moreover, if the input data is prepared ahead of time and is made available to the system in its entirety, then the causality restriction can be relaxed altogether. This can be feasible in applications, where the entire training data set or a collection of independent training data segments is gathered before processing commences. Non-causal processing (i.e., a technique characterized by taking advantage of the input data “from the future”) can be advantageous in detecting the presence of “context” among data samples. Utilizing the information at the “future” steps as part of context for making decisions at the “current” step is often beneficial for analyzing audio, speech, and text.

18

    The significance of the element-wise control of the “content” signals (here called the “data” signals) exerted by the gates in the LSTM network has been independently recognized and researched by others  [73] .

19

    Note the notation change: in the rest of the document, the symbol, u → [ n ] , has the meaning of the update candidate signal (not the vector-valued unit step function).

20

    However, the design of the LSTM network does not address explicitly the exploding gradients problem. During training, the derivatives can still become excessively large, leading to numerical problems. To prevent this, all derivatives of the objective function with respect to the state signal are renormalized to lie within a predefined range [19] , [22] , [63] .

21

    Because of the access control functionality provided by the gates, the LSTM cell is sometimes interpreted as a differentiable version of the digital static random access memory cell  [19] .

22

    In certain advanced RNN and LSTM configurations, such as Attention Networks, the state signal is externally observable and serves as an important component of the objective function.

23

    The test and validation sets should be standardized with the mean and standard deviation of the training set  [22] .

24

    If the cell is unrolled in the opposite direction, then n − 1 is replaced by n + 1 , and the direction of evaluating the steps is reversed. For the bi-directional unrolling, the steps in both the positive and the negative directions of the index, n , need to be evaluated  [72] . Here, only the positive direction is considered.

25

    As noted in Section  5 , during training, the total derivatives of the objective function, E , with respect to the cell’s accumulation signals (“accumulation derivatives”) can become excessively large. In order to prevent these kinds of numerical problems, all accumulation derivatives are clipped to lie between − 1 and 1 , a range that is suitable for the particular choices of the control and data warping functions  [19] , [22] , [63] .

26

    Depending on the application, the batch sizes typically range between 16 and 128 segments.

27

    Regularization, while outside of the scope of the present article, is an essential aspect of machine learning model training process  [78] .

28

    The notation, diag [ z → ] , represents a diagonal matrix, in which the elements of the vector, z → , occupy the main diagonal.

29

    Note that all data signals in Eq.  (178) ( u → , s → , and r → ) have the dynamic range of 2 , because they are at the output node of the warping function, G d ( z → ) , which is the hyperbolic tangent. Hence, for the respective term to have the norm of < 1 , the associated parameter matrices must have the norm of < 1 2 .

30

    As the members of the expanded LSTM model’s parameter set, Θ , the new matrices and bias vectors are learned during the training phase.

31

    The non-causal input context windows can be readily employed as part of the bi-directional RNN or LSTM network. The number of additional parameter matrices to support input convolutions will double compared to the uni-directional case, because the samples covered by the windows are situated on the positive side along the direction of the sequence.

32

    This new matrix of weights, to be learned as part of training, is known as the “recurrent projection layer”  [24] .

33

    In our nomenclature, the matrix of weights, W q d r , links the cell’s “qualifier” signal, q → [ n ] , with the cell’s value signal, v → [ n ] , along the readout data path of the cell.

View Abstract
© 2019 Elsevier B.V. All rights reserved.
Part of special issue
Machine Learning and Dynamical Systems
Edited by Boumediene Hamzi, Jeroen Lamb, Lorenzo Livi, Qianxiao Li
View special issue
Recommended articles

    A GRU-RNN based momentum optimized algorithm for SOC estimation
    Journal of Power Sources, Volume 459, 2020, Article 228051
    Meng Jiao , …, Jianlong Qiu
    View PDF
    Developing a Long Short-Term Memory (LSTM) based model for predicting water table depth in agricultural areas
    Journal of Hydrology, Volume 561, 2018, pp. 918-929
    Jianfeng Zhang , …, Jinzhong Yang
    View PDF
    Deep Learning with Gated Recurrent Unit Networks for Financial Sequence Predictions
    Procedia Computer Science, Volume 131, 2018, pp. 895-903
    Guizhu Shen , …, Jianjun Xu
    View PDF

Show 3 more articles
Article Metrics
Citations

    Citation Indexes: 2050 

Captures

    Readers: 2711 

Social Media

    Shares, Likes & Comments: 37 

plumX logo
View details
Elsevier logo with wordmark

    About ScienceDirect
    Remote access
    Shopping cart
    Advertise
    Contact and support
    Terms and conditions
    Privacy policy 

Cookies are used by this site. Cookie Settings

All content on this site: Copyright © 2024 Elsevier B.V., its licensors, and contributors. All rights are reserved, including those for text and data mining, AI training, and similar technologies. For all open access content, the Creative Commons licensing terms apply.
RELX group home page
